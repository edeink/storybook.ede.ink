import{f as r,D as n,c as d,o as s,k as t,a4 as e,H as o,a as l}from"./chunks/framework.BAs4fWuZ.js";const _=JSON.parse('{"title":"Web 编辑器：核心架构与“轮点”演进","description":"","frontmatter":{"title":"Web 编辑器：核心架构与“轮点”演进","date":"2026-01-18T00:00:00.000Z","categories":"study","tags":["web-editor","prosemirror","architecture","performance"]},"headers":[],"relativePath":"web-editor/01-editor-architecture.md","filePath":"web-editor/01-editor-architecture.md","lastUpdated":1769026429000}'),c={name:"web-editor/01-editor-architecture.md"};function p(h,i,u,b,m,g){const a=n("InkMermaidBlock");return s(),d("div",null,[i[0]||(i[0]=t("div",{class:"alert read-stats",role:"note"},[t("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),t("span",{class:"read-stats__text"},[l("本文约 "),t("b",null,"3587"),l(" 字，阅读预计耗时 "),t("b",null,"9"),l(" 分钟。")])],-1)),i[1]||(i[1]=t("div",{class:"alert ai-disclosure",role:"note"},[t("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),t("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),i[2]||(i[2]=e('<p>你以为在写前端，最后是在和输入法、浏览器 bug、数据结构以及人性对抗。</p><h2 id="问题-为什么做一个-web-编辑器-总会走向-底层" tabindex="-1">问题：为什么做一个 Web 编辑器，总会走向“底层”？ <a class="header-anchor" href="#问题-为什么做一个-web-编辑器-总会走向-底层" aria-label="Permalink to &quot;问题：为什么做一个 Web 编辑器，总会走向“底层”？&quot;">​</a></h2><p>最开始，我也以为编辑器就是 <code>contenteditable</code> + 一堆 DOM 操作：键盘事件拦一下、回车换行、粘贴做个 sanitize、再加点样式，齐活。</p><p>后来发现，越做越不对劲：</p><ul><li>输入法（IME）一来，你的 keydown/keyup 逻辑就开始失效</li><li>光标在表格边缘、不可编辑节点旁边，会出现各种“幽灵选区”</li><li>大文档（几万字 + 大量节点）一更新就抖，CPU 飙升</li><li>做协同后，DOM 只是结果；“事实”应该是可回放的操作日志</li></ul><p>究其根本：DOM 不是一个可靠的“真相来源”（source of truth）。编辑器要可控、可回放、可协同，你需要一个 <strong>Document Model</strong>（文档模型）作为底层事实。</p><h2 id="分析-核心架构的三条主线" tabindex="-1">分析：核心架构的三条主线 <a class="header-anchor" href="#分析-核心架构的三条主线" aria-label="Permalink to &quot;分析：核心架构的三条主线&quot;">​</a></h2><p>我习惯把编辑器拆成三条流水线（管道/pipeline）：</p><ol><li>输入线（Input Pipeline）：浏览器事件 → 编辑意图（intent） → 事务</li><li>状态线（State Pipeline）：事务 → 文档模型变更 → 历史/协同日志</li><li>渲染线（Render Pipeline）：文档模型 → 视图（DOM/Canvas） → 交互回流</li></ol><p>这三条线看起来像“架构图上的三根箭头”，但工程上它们分别对应三类最难的问题：</p><ul><li>输入线难在“不可控”：IME、浏览器差异、组合输入会让事件序列变得不像人类写的</li><li>状态线难在“可证明”：每一次变化都要可回放、可合并、可校验，不然协同与撤销迟早出事</li><li>渲染线难在“可交互”：你不仅要画出来，还要能反查（hit testing）、能映射选区（selection mapping）、能增量更新（否则长文档必卡）</li></ul><h3 id="架构图-源文件-assets-diagrams-editor-architecture-mmd" tabindex="-1">架构图（源文件：<code>../assets/diagrams/editor-architecture.mmd</code>） <a class="header-anchor" href="#架构图-源文件-assets-diagrams-editor-architecture-mmd" aria-label="Permalink to &quot;架构图（源文件：`../assets/diagrams/editor-architecture.mmd`）&quot;">​</a></h3>',12)),o(a,{codeBase64:"Zmxvd2NoYXJ0IExSCiAgc3ViZ3JhcGggSW5wdXRbIui+k+WFpee6v++8mua1j+iniOWZqOS6i+S7tiDihpIgaW50ZW50Il0KICAgIEVbRE9NIEV2ZW50czxici8+a2V5ZG93bi9jb21wb3NpdGlvbi9wYXN0ZV0gLS0+IElbSW50ZW50PGJyLz5Db21tYW5kL0lucHV0UnVsZV0KICAgIEkgLS0+IFRbVHJhbnNhY3Rpb25dCiAgZW5kCgogIHN1YmdyYXBoIFN0YXRlWyLnirbmgIHnur/vvJp0cmFuc2FjdGlvbiDihpIgbW9kZWwiXQogICAgVCAtLT4gU1tTdGVwcyAvIFBhdGNoZXNdCiAgICBTIC0tPiBEW0RvY3VtZW50IE1vZGVsPGJyLz5TY2hlbWEgKyBUcmVlXQogICAgUyAtLT4gSFtIaXN0b3J5PGJyLz51bmRvL3JlZG9dCiAgICBTIC0tPiBDW0NvbGxhYiBMb2c8YnIvPk9UL0NSRFQgb3BzXQogIGVuZAoKICBzdWJncmFwaCBSZW5kZXJbIua4suafk+e6v++8mm1vZGVsIOKGkiB2aWV3Il0KICAgIEQgLS0+IFZbVmlldyBMYXllcjxici8+RE9NL0NhbnZhcy9IeWJyaWRdCiAgICBWIC0tPiBTZWxbU2VsZWN0aW9uIE1hcHBpbmddCiAgICBTZWwgLS0+fOWPjemmiHwgSQogIGVuZAo="}),i[3]||(i[3]=e('<h3 id="主流方案横向对比-表格" tabindex="-1">主流方案横向对比（表格） <a class="header-anchor" href="#主流方案横向对比-表格" aria-label="Permalink to &quot;主流方案横向对比（表格）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方案</th><th>核心模型</th><th>扩展方式</th><th>协同生态</th><th>优势</th><th>常见坑</th></tr></thead><tbody><tr><td>ProseMirror</td><td>Schema + Transaction + Step</td><td>Plugin/NodeView/Mark</td><td>强（社区成熟）</td><td>模型严谨、可回放、可扩展</td><td>学习曲线陡，边界条件多</td></tr><tr><td>Slate</td><td>Immutable-ish Tree</td><td>Custom plugins</td><td>中（需要组合方案）</td><td>React 生态友好、自由度高</td><td>自由度带来一致性成本</td></tr><tr><td>Lexical</td><td>EditorState + Node</td><td>Lexical plugins</td><td>中</td><td>性能与工程化较强</td><td>生态与富文本复杂度仍在演进</td></tr><tr><td>Quill</td><td>Delta（ops）</td><td>Modules/Blots</td><td>中</td><td>入门快，编辑体验成熟</td><td>深度定制会碰到结构天花板</td></tr></tbody></table><p>四舍五入：差异不是“谁更强”，而是你想把复杂度放在哪一层——放在框架里，还是放在业务里。</p><h2 id="细节-输入线为什么是-野生动物园" tabindex="-1">细节：输入线为什么是“野生动物园” <a class="header-anchor" href="#细节-输入线为什么是-野生动物园" aria-label="Permalink to &quot;细节：输入线为什么是“野生动物园”&quot;">​</a></h2><p>编辑器的输入不是只有 keydown/keyup。真实世界里你会遇到：</p><ul><li>IME（composition）：输入法会把一次“打字”变成多次中间态更新，且光标与文本会被浏览器临时接管</li><li>粘贴（paste/beforeinput）：你以为是粘贴一段 HTML，实际上可能是 Office/飞书/网页复制的半结构化垃圾</li><li>拖拽（drag/drop）：拖进来的既可能是文本，也可能是图片文件、链接、甚至自定义对象</li><li>移动端：长按、选词、输入建议、系统键盘的“自动纠错”，都会改写你的文本</li></ul><p>把它类比成“翻译系统”会更贴切：浏览器事件只是原始语料，编辑器要做的是把它们翻译成稳定的意图（insertText、deleteRange、splitBlock…）。</p><p>因此一个更稳的输入线会有两个显式阶段：</p><ul><li>捕获阶段：尽量少做决定，只收集事实（事件类型、range、文本、是否处于 composition）</li><li>解释阶段：把事实翻译成 intent，并决定是否生成 transaction（必要时合并为一个批次）</li></ul><h2 id="细节-状态线的关键不是-apply-而是-约束与回放" tabindex="-1">细节：状态线的关键不是 apply，而是“约束与回放” <a class="header-anchor" href="#细节-状态线的关键不是-apply-而是-约束与回放" aria-label="Permalink to &quot;细节：状态线的关键不是 apply，而是“约束与回放”&quot;">​</a></h2><p>状态线最容易偷懒的地方是：把任何修改都直接 apply 到 doc，然后“差不多就行”。但编辑器一旦复杂起来，状态线必须做三件事：</p><ol><li>normalize：把文档修到合法结构</li></ol><ul><li>例如列表里不能直接塞段落以外的块；表格里每行列数要一致</li><li>normalize 不是锦上添花，而是协同与插件的安全带：你不能相信外部输入永远合法</li></ul><ol start="2"><li>记录事实：transaction/step/oplog</li></ol><ul><li>事实的意义是回放：能把用户的每次编辑在任何机器上重演</li><li>事实的意义也是排障：出了“偶现丢字”，你可以拿日志重放，而不是靠玄学复现</li></ul><ol start="3"><li>合并策略：把“人类一次操作”表达成“系统的一次事务”</li></ol><ul><li>用户按住退格删除一段，系统可能产生几十次输入事件</li><li>如果你把它们都记进历史，撤销体验会变成灾难</li><li>因此需要合并规则：按时间窗口、按输入类型、按 selection 变化等策略合并</li></ul><h2 id="细节-渲染线里最贵的是-可交互性" tabindex="-1">细节：渲染线里最贵的是“可交互性” <a class="header-anchor" href="#细节-渲染线里最贵的是-可交互性" aria-label="Permalink to &quot;细节：渲染线里最贵的是“可交互性”&quot;">​</a></h2><p>渲染线不只是把 doc 画出来，它还要回答交互问题：</p><ul><li>点击某个像素点，对应 doc 的哪个位置？</li><li>选区跨行跨节点时，要画哪些 rect？</li><li>视口只渲染一部分时，如何保证 selection 与协同光标仍能正确映射？</li></ul><p>这就是为什么很多编辑器会把“几何缓存（geometry cache）”当成一等公民：它既服务渲染，也服务 hit testing 与 selection。你可以把它理解成“版面账本”，没有账本，交互就只能靠猜。</p><h2 id="解决方案-把-轮点-当成架构演进的坐标轴" tabindex="-1">解决方案：把“轮点”当成架构演进的坐标轴 <a class="header-anchor" href="#解决方案-把-轮点-当成架构演进的坐标轴" aria-label="Permalink to &quot;解决方案：把“轮点”当成架构演进的坐标轴&quot;">​</a></h2><p>这里的“轮点”不是玄学，它只是我用来标注编辑器演进里程碑的词：每跨过一个轮点，你的系统会换一套“底层真相”。</p><h3 id="轮点-0-contenteditable-dom-操作" tabindex="-1">轮点 0：<code>contenteditable</code> + DOM 操作 <a class="header-anchor" href="#轮点-0-contenteditable-dom-操作" aria-label="Permalink to &quot;轮点 0：`contenteditable` + DOM 操作&quot;">​</a></h3><ul><li>真相来源：DOM</li><li>好处：开发快</li><li>代价：不可控、不可回放、协同难</li></ul><h3 id="轮点-1-文档模型成为真相-model-first" tabindex="-1">轮点 1：文档模型成为真相（Model-first） <a class="header-anchor" href="#轮点-1-文档模型成为真相-model-first" aria-label="Permalink to &quot;轮点 1：文档模型成为真相（Model-first）&quot;">​</a></h3><ul><li>真相来源：Document Model（树 + schema + transaction）</li><li>关键收益：可回放（replayable）、可测试（testable）、可协同（collab-ready）</li><li>关键代价：你必须实现 Selection mapping、IME 兼容、渲染 diff</li></ul><h3 id="轮点-2-协同成为第一公民-collab-first" tabindex="-1">轮点 2：协同成为第一公民（Collab-first） <a class="header-anchor" href="#轮点-2-协同成为第一公民-collab-first" aria-label="Permalink to &quot;轮点 2：协同成为第一公民（Collab-first）&quot;">​</a></h3><ul><li>真相来源：操作日志（OT/CRDT ops）+ 快照</li><li>关键收益：多人一致性、离线/重连、审计与回放</li><li>关键代价：压缩、回放性能、冲突语义（富文本远比纯文本难）</li></ul><h3 id="轮点-3-ai-agent-成为交互入口-context-first" tabindex="-1">轮点 3：AI/Agent 成为交互入口（Context-first） <a class="header-anchor" href="#轮点-3-ai-agent-成为交互入口-context-first" aria-label="Permalink to &quot;轮点 3：AI/Agent 成为交互入口（Context-first）&quot;">​</a></h3><ul><li>真相来源：用户意图（selection + doc slice）与上下文窗口</li><li>关键收益：自然语言成为命令、自动化成为默认交互</li><li>关键代价：安全与权限、可解释性、可回滚的“AI 事务”</li></ul><h2 id="解决方案-用-抽象骨架-把编辑器讲清楚-少代码-多细节" tabindex="-1">解决方案：用“抽象骨架”把编辑器讲清楚（少代码，多细节） <a class="header-anchor" href="#解决方案-用-抽象骨架-把编辑器讲清楚-少代码-多细节" aria-label="Permalink to &quot;解决方案：用“抽象骨架”把编辑器讲清楚（少代码，多细节）&quot;">​</a></h2><p>如果把编辑器比作一个餐厅后厨：</p><ul><li>输入线像“点单员”：把用户手势翻译成可执行意图（回车、删除、粘贴、拖拽）</li><li>状态线像“厨师”：按配方（schema）把食材（doc）加工成新菜（next doc）</li><li>渲染线像“传菜员”：把最终菜品端到桌上（DOM/Canvas），并保证桌号没送错（selection mapping）</li></ul><p>你会发现：后厨最怕的不是“做菜”，而是“订单乱、桌号错、厨师抢锅”。编辑器也是：抽象不清的时候，bug 就会以“玄学”的形式出现。</p><p>下面用更偏“数学+自然语言”的方式，把几个关键抽象讲透（尽量不靠长代码）。</p><h3 id="抽象-1-文档模型-document-model-到底是什么" tabindex="-1">抽象 1：文档模型（Document Model）到底是什么？ <a class="header-anchor" href="#抽象-1-文档模型-document-model-到底是什么" aria-label="Permalink to &quot;抽象 1：文档模型（Document Model）到底是什么？&quot;">​</a></h3><p>先把富文本降到一个“可计算”的形态：</p>',38)),i[4]||(i[4]=t("ul",null,[t("li",null,"文档是一个有序序列：Doc = [B₁, B₂, …]（block 列表）"),t("li",null,"一个段落是 inline 序列：P = [I₁, I₂, …]"),t("li",{"Text(s),":"","InlineNode(type,":"","attrs)":""},"inline 里要么是文本片段，要么是内联节点：I ∈"),t("li",null,"schema 不是“类型定义”，它更像“交通规则”：什么能插哪、哪些组合违法、违法了怎么修复")],-1)),i[5]||(i[5]=e('<p>比喻一下：DOM 像“现场的摆盘”，schema+doc 像“菜谱+食材清单”。你当然可以只盯着摆盘操作，但一旦多人协作、撤销重做、跨端渲染，摆盘就不再是可靠事实了。</p><h3 id="抽象-2-事务-transaction-与步骤-step-为什么是-真相" tabindex="-1">抽象 2：事务（Transaction）与步骤（Step）为什么是“真相”？ <a class="header-anchor" href="#抽象-2-事务-transaction-与步骤-step-为什么是-真相" aria-label="Permalink to &quot;抽象 2：事务（Transaction）与步骤（Step）为什么是“真相”？&quot;">​</a></h3><p>我喜欢把 transaction 看成“银行流水”：</p><ul><li>doc 是账户余额（最终状态）</li><li>step 是每一笔交易（可回放、可审计）</li><li>transaction 是一段连续的流水（可以合并、可以重放、可以同步）</li></ul><p>最常见的文本插入可以用一个简单的式子表达清楚：</p><ul><li>给定某个文本片段 t，以及插入位置 k，插入字符串 x</li><li>新文本 t′ = t[0..k) ⧺ x ⧺ t[k..|t|)</li></ul><p>为什么强调这个式子？因为它暴露了编辑器最真实的边界条件：</p><ul><li>k 可能越界（来自协同重放、插件注入、旧选区映射）</li><li>x 可能为空（应当视为 no-op，避免污染 history/oplog）</li><li>t 可能不是“单一字符串”，而是多个片段拼起来（长文档会用 piece table/rope 之类结构，后面专门讲）</li></ul><h3 id="抽象-3-selection-mapping-为什么光标像-幽灵" tabindex="-1">抽象 3：Selection mapping：为什么光标像“幽灵”？ <a class="header-anchor" href="#抽象-3-selection-mapping-为什么光标像-幽灵" aria-label="Permalink to &quot;抽象 3：Selection mapping：为什么光标像“幽灵”？&quot;">​</a></h3><p>selection mapping 本质是：把“旧坐标系的光标位置”搬运到“新坐标系”。</p><p>如果用一维偏移描述最简单的插入/删除：</p><ul><li>插入：pos′ = pos + |x|（当 pos ≥ k 时；否则不变）</li><li>删除：[a, b) 删除后，pos′ = max(a, pos - (b - a))（更准确需要分情况讨论）</li></ul><p>看起来像小学生数学题，但编辑器里它会长出牙齿：</p><ul><li>富文本不是一维：节点边界、不可编辑节点、表格单元格都会改变“可落点集合”</li><li>selection 不是一个点：可能是区间、可能是 node selection、可能是 gap cursor</li><li>浏览器输入不是离散事件：IME composition 期间 selection 会漂移，且浏览器会做一些“你没看到的修正”</li></ul><p>所以你会看到很多“幽灵现象”：光标跳一下、选区闪一下、回车后落点不在预期。它们大多数不是渲染 bug，而是 mapping 不完整（或者你在错误的时机做了 mapping）。</p><h3 id="一张-事务回放-的流程图-你应该能在纸上推一遍" tabindex="-1">一张“事务回放”的流程图：你应该能在纸上推一遍 <a class="header-anchor" href="#一张-事务回放-的流程图-你应该能在纸上推一遍" aria-label="Permalink to &quot;一张“事务回放”的流程图：你应该能在纸上推一遍&quot;">​</a></h3>',16)),o(a,{codeBase64:"Zmxvd2NoYXJ0IFRCCiAgRVvkuovku7Y6IGtleWRvd24vcGFzdGUvY29tcG9zaXRpb25dIC0tPiBJW+aEj+WbvjogY29tbWFuZC9pbnB1dCBydWxlXQogIEkgLS0+IFRSW+eUn+aIkCB0cmFuc2FjdGlvbl0KICBUUiAtLT58c3RlcHN8IEFQW0FwcGx5OiBkb2MgOj0gYXBwbHkoZG9jLCBzdGVw4bWiKV0KICBBUCAtLT4gSFtIaXN0b3J5OiBwdXNoIHVuZG8gLyBjbGVhciByZWRvXQogIEFQIC0tPiBMW0xvZzog6K6w5b2VIG9wbG9nIC8gbWV0cmljc10KICBBUCAtLT4gVltWaWV3OiDmnIDlsI/ljJbmm7TmlrBdCiAgViAtLT4gTVtTZWxlY3Rpb24gbWFwcGluZ10KICBNIC0tPiBFCg=="}),i[6]||(i[6]=e('<p>建议你在实现时，强迫自己写下三组“可观测指标”，否则性能与稳定性会变成玄学：</p><ul><li>事务层：step 数量、step 类型分布、是否合并、是否 no-op</li><li>渲染层：更新范围、layout 次数、重排/重绘开销、是否跨帧</li><li>交互层：selection mapping 耗时、composition 期间回退次数、输入失败率</li></ul><h2 id="性能优化与异常处理-把坑写在纸面上-别留给线上" tabindex="-1">性能优化与异常处理：把坑写在纸面上（别留给线上） <a class="header-anchor" href="#性能优化与异常处理-把坑写在纸面上-别留给线上" aria-label="Permalink to &quot;性能优化与异常处理：把坑写在纸面上（别留给线上）&quot;">​</a></h2><h3 id="性能-大文档下-每次全量-render-会死" tabindex="-1">性能：大文档下“每次全量 render”会死 <a class="header-anchor" href="#性能-大文档下-每次全量-render-会死" aria-label="Permalink to &quot;性能：大文档下“每次全量 render”会死&quot;">​</a></h3><ul><li>优先做增量：以 Step 为单位驱动更新（范围更新，而非整棵树）</li><li>预算化：一次事务的渲染预算（比如 8ms），超预算则分帧</li><li>观察：记录 step 数量、渲染耗时、selection mapping 耗时，形成可回放日志</li></ul><h3 id="异常-插件与输入法是-野生动物" tabindex="-1">异常：插件与输入法是“野生动物” <a class="header-anchor" href="#异常-插件与输入法是-野生动物" aria-label="Permalink to &quot;异常：插件与输入法是“野生动物”&quot;">​</a></h3><ul><li>插件异常必须隔离：一个插件 throw 不能让编辑器整体不可用</li><li>关键状态必须可恢复：文档模型可回放（transaction log）是救命稻草</li><li>IME 必须尊重 composition：不要用 keydown 强行改 DOM，再让浏览器补刀</li></ul><h3 id="一个更-工程化-的建议-先把失败场景写出来" tabindex="-1">一个更“工程化”的建议：先把失败场景写出来 <a class="header-anchor" href="#一个更-工程化-的建议-先把失败场景写出来" aria-label="Permalink to &quot;一个更“工程化”的建议：先把失败场景写出来&quot;">​</a></h3><p>很多编辑器事故不是“功能没做”，而是“失败时不优雅”。你可以把它当成灾备演练：</p><ul><li>插件坏了：是否能降级到只读/纯文本？是否能快速禁用某个插件？</li><li>文档脏了：是否能用 oplog 回放定位哪一步把数据写坏？</li><li>性能抖了：是否能在日志里看到“哪类 step 触发了哪次 layout storm”？</li><li>选区错了：是否能复现出“输入法/浏览器版本/文档结构”的最小组合？</li></ul><h2 id="落地-从-0-到-1-的最小骨架-不追求完美-但追求可演进" tabindex="-1">落地：从 0 到 1 的最小骨架（不追求完美，但追求可演进） <a class="header-anchor" href="#落地-从-0-到-1-的最小骨架-不追求完美-但追求可演进" aria-label="Permalink to &quot;落地：从 0 到 1 的最小骨架（不追求完美，但追求可演进）&quot;">​</a></h2><p>如果你要在一周内“搭出一个不会自爆的骨架”，我会把目标定成三句话：</p><ol><li>任何编辑都必须变成一个 transaction</li><li>任何 transaction 都必须可回放、可合并、可丢弃（no-op）</li><li>任何渲染都必须能解释“它为什么变了”（由哪些 step 驱动）</li></ol><p>把它落实成工程上的几个硬约束：</p><ul><li><strong>输入与状态隔离</strong>：输入层不直接改 doc；它只产生 intent，交给状态层决定是否落地</li><li><strong>状态变化可验证</strong>：apply 之后立刻做一次 cheap 校验（结构合法、关键不变量成立），失败则拒绝或降级</li><li><strong>渲染变化可追踪</strong>：渲染层记录“更新范围”和“耗时”，并能关联回触发它的 transaction id</li></ul><h3 id="建议的不变量-可以当成-交通规则-贴在墙上" tabindex="-1">建议的不变量（可以当成“交通规则”贴在墙上） <a class="header-anchor" href="#建议的不变量-可以当成-交通规则-贴在墙上" aria-label="Permalink to &quot;建议的不变量（可以当成“交通规则”贴在墙上）&quot;">​</a></h3><p>编辑器里的不变量很像城市道路的红绿灯：平时你觉得它啰嗦，但事故发生时，它是唯一能把责任说清楚的东西。</p><ul><li><strong>Schema 不变量</strong>：每个节点的 children 结构必须满足 schema；不满足就 normalize</li><li><strong>位置不变量</strong>：所有 position 都必须指向“可落点集合”里的某个落点；否则必须被修正为最近合法落点</li><li><strong>事务不变量</strong>：transaction 中每个 step 的前置条件必须成立（例如删除区间必须存在、插入目标必须可插入）</li></ul><p>你可以把它写成“可推演”的形式：对每个 step 定义前置条件 P(step) 与效果 E(step)。当某次事故发生时，你要回答的问题不是“为什么光标乱跳”，而是“哪一个 step 的 P 没满足却仍然执行了”。</p><h3 id="用-预算-而不是-感觉-来做性能" tabindex="-1">用“预算”而不是“感觉”来做性能 <a class="header-anchor" href="#用-预算-而不是-感觉-来做性能" aria-label="Permalink to &quot;用“预算”而不是“感觉”来做性能&quot;">​</a></h3><p>很多项目做编辑器性能优化时，会陷入一种误区：看到卡顿就去微调 diff 逻辑，结果越调越玄学。更稳的做法是先把系统变成“可计价”的：</p><ul><li>一次事务的总成本：T = T_apply + T_normalize + T_render + T_map</li><li>你关心的不是平均值，而是尾部：P95(T)、P99(T)</li><li>你真正要压的不是所有事务，而是“高频且高成本”的那一类（例如连续输入、长段删除、跨节点粘贴）</li></ul><p>当你能把一次卡顿定位为“某个 step 导致 T_render 暴涨”，优化就从艺术变成工程：你可以选择缩小更新范围、分帧、或者把某些昂贵计算推迟到 idle。</p><h2 id="参考与引用" tabindex="-1">参考与引用 <a class="header-anchor" href="#参考与引用" aria-label="Permalink to &quot;参考与引用&quot;">​</a></h2><ol><li>ProseMirror Guide: <a href="https://prosemirror.net/docs/guide/" target="_blank" rel="noreferrer">https://prosemirror.net/docs/guide/</a> （Bib: <code>prosemirror_guide</code>）</li><li>W3C Input Events Level 2: <a href="https://w3c.github.io/input-events/" target="_blank" rel="noreferrer">https://w3c.github.io/input-events/</a> （Bib: <code>w3c_input_events</code>）</li><li>Yjs Documentation: <a href="https://docs.yjs.dev/" target="_blank" rel="noreferrer">https://docs.yjs.dev/</a> （Bib: <code>yjs_docs</code>）</li></ol>',25))])}const f=r(c,[["render",p]]);export{_ as __pageData,f as default};
