import{f as t,D as s,c,o as d,k as r,a5 as i,H as o,a}from"./chunks/framework.BsEAYNxL.js";const b=JSON.parse('{"title":"Chromium 架构总览：多进程与线程模型","description":"","frontmatter":{"title":"Chromium 架构总览：多进程与线程模型","date":"2026-01-20T00:00:00.000Z","categories":"study","tags":["browser-rendering","chromium","architecture","process","threads","blink","viz"]},"headers":[],"relativePath":"browser-rendering/01-chromium-architecture-processes-and-threads.md","filePath":"browser-rendering/01-chromium-architecture-processes-and-threads.md","lastUpdated":1769663832000}'),m={name:"browser-rendering/01-chromium-architecture-processes-and-threads.md"};function n(I,e,C,g,h,u){const l=s("InkMermaidBlock");return d(),c("div",null,[e[0]||(e[0]=r("div",{class:"alert read-stats",role:"note"},[r("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),r("span",{class:"read-stats__text"},[a("本文约 "),r("b",null,"1131"),a(" 字，阅读预计耗时 "),r("b",null,"3"),a(" 分钟。")])],-1)),e[1]||(e[1]=r("div",{class:"alert ai-disclosure",role:"note"},[r("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),r("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),e[2]||(e[2]=i('<p>很多前端性能问题之所以难定位，并不是“原因很多”，而是“边界很多”：你以为只有一个主线程在忙，实际上是一堆进程/线程在排队、同步、互相等。</p><p>这一章的目标只有一个：把 Chromium 的边界画清楚。你不需要把源码背下来，但你需要知道“这个活是谁干的”，否则优化永远是在黑箱里祈祷。</p><h2 id="_1-一句话地图-从-tab-到像素-分成几类进程" tabindex="-1">1. 一句话地图：从 Tab 到像素，分成几类进程 <a class="header-anchor" href="#_1-一句话地图-从-tab-到像素-分成几类进程" aria-label="Permalink to &quot;1. 一句话地图：从 Tab 到像素，分成几类进程&quot;">​</a></h2><p>一个现代 Chromium（Chrome/Edge）大体可以理解成这几类进程（会随平台、feature、版本变化）：</p><ul><li>Browser process：导航、权限、安全策略、进程管理、输入事件路由、UI 相关</li><li>Renderer process：一个或多个网页 Frame 的执行与渲染（Blink + V8）</li><li>GPU process：图形驱动隔离、GPU 命令提交、部分合成/显示路径</li><li>Network service：网络栈与缓存（HTTP、QUIC、proxy、cache 等）</li><li>Utility processes：解码、文件、音视频等更细的隔离单元</li></ul><p>你可以先把它们当成一个约定：<strong>能隔离就隔离，能并行就并行</strong>。安全与稳定是第一动机，性能与并发是第二收益。</p><h3 id="架构图-多进程模型" tabindex="-1">架构图：多进程模型 <a class="header-anchor" href="#架构图-多进程模型" aria-label="Permalink to &quot;架构图：多进程模型&quot;">​</a></h3>',7)),o(l,{codeBase64:"Zmxvd2NoYXJ0IFRCCiAgICBCcm93c2VyW0Jyb3dzZXIgUHJvY2Vzczxici8+KFVJLCBJTywgQ29vcmRpbmF0b3IpXQogICAgCiAgICBzdWJncmFwaCBSZW5kZXJlcnNbIlJlbmRlcmVyIFByb2Nlc3NlcyAoU2FuZGJveGVkKSJdCiAgICAgICAgZGlyZWN0aW9uIFRCCiAgICAgICAgUjFbUmVuZGVyZXIgMTxici8+KFRhYiBBKV0KICAgICAgICBSMltSZW5kZXJlciAyPGJyLz4oVGFiIEIpXQogICAgZW5kCiAgICAKICAgIEdQVVtHUFUgUHJvY2Vzczxici8+KEdyYXBoaWNzLCBDb21wb3NpdGUpXQogICAgTmV0d29ya1tOZXR3b3JrIFNlcnZpY2U8YnIvPihIVFRQLCBDYWNoZSldCiAgICAKICAgIEJyb3dzZXIgPD09PnxJUEN8IFIxCiAgICBCcm93c2VyIDw9PT58SVBDfCBSMgogICAgQnJvd3NlciA8PT0+fElQQ3wgR1BVCiAgICBCcm93c2VyIDw9PT58SVBDfCBOZXR3b3JrCiAgICAKICAgIFIxIC0uLT58Q29tbWFuZCBCdWZmZXJ8IEdQVQogICAgUjIgLS4tPnxDb21tYW5kIEJ1ZmZlcnwgR1BVCiAgICBSMSAtLi0+fEZldGNofCBOZXR3b3JrCiAgICAKICAgIGNsYXNzRGVmIG1haW4gZmlsbDojZTFmNWZlLHN0cm9rZTojMDE1NzliLGNvbG9yOiMwMDA7CiAgICBjbGFzc0RlZiB3b3JrZXIgZmlsbDojZmZmM2UwLHN0cm9rZTojZTY1MTAwLGNvbG9yOiMwMDA7CiAgICBjbGFzc0RlZiBzZXJ2aWNlIGZpbGw6I2U4ZjVlOSxzdHJva2U6IzJlN2QzMixjb2xvcjojMDAwOwogICAgCiAgICBjbGFzcyBCcm93c2VyIG1haW47CiAgICBjbGFzcyBSMSxSMiB3b3JrZXI7CiAgICBjbGFzcyBHUFUsTmV0d29yayBzZXJ2aWNlOwo="}),e[3]||(e[3]=i('<h2 id="_2-site-isolation-与-frame-tree-同一个页面-可能不止一个-renderer" tabindex="-1">2. Site Isolation 与 Frame Tree：同一个页面，可能不止一个 Renderer <a class="header-anchor" href="#_2-site-isolation-与-frame-tree-同一个页面-可能不止一个-renderer" aria-label="Permalink to &quot;2. Site Isolation 与 Frame Tree：同一个页面，可能不止一个 Renderer&quot;">​</a></h2><p>“一个 tab 对应一个渲染进程”是过时直觉。Chromium 更接近：</p><ul><li>一个 tab 有一个 Frame Tree（主 frame + 子 frame）</li><li>不同 frame 可能驻留在不同 renderer process（尤其跨站 iframe）</li></ul><p>这背后是 Site Isolation / OOPIF（Out-Of-Process Iframe）这类机制：隔离跨站内容，降低攻击面。</p><p>工程后果是很现实的：</p><ul><li>同屏多 iframe 卡顿时，先别假设只有一个主线程在忙</li><li>输入事件、合成、同步点会跨进程走一圈，延迟归因会更“非直觉”</li></ul>',6)),o(l,{codeBase64:"Zmxvd2NoYXJ0IFRCCiAgc3ViZ3JhcGggVGFiWyLkuIDkuKogVGFi77yI5qaC5b+177yJIl0KICAgIEZUWyJGcmFtZSBUcmVlPGJyLz5tYWluIGZyYW1lICsgc3ViZnJhbWVzIl0KICBlbmQKCiAgc3ViZ3JhcGggQnJvd3NlclsiQnJvd3NlciBwcm9jZXNzIl0KICAgIE5hdlsiTmF2aWdhdGlvbiAvIFBvbGljeSAvIFBlcm1pc3Npb25zIl0KICAgIFJvdXRlclsiSW5wdXQgcm91dGluZyJdCiAgZW5kCgogIHN1YmdyYXBoIFIxWyJSZW5kZXJlciBB77yIbWFpbiBmcmFtZe+8iSJdCiAgICBCbGluazFbIkJsaW5rPGJyLz5ET00vQ1NTL0xheW91dC9QYWludCJdCiAgICBWODFbIlY4PGJyLz5KUy9HQyJdCiAgZW5kCgogIHN1YmdyYXBoIFIyWyJSZW5kZXJlciBC77yIY3Jvc3Mtc2l0ZSBpZnJhbWXvvIkiXQogICAgQmxpbmsyWyJCbGluayJdCiAgICBWODJbIlY4Il0KICBlbmQKCiAgRlQgLS0+IFIxCiAgRlQgLS0+IFIyCiAgQnJvd3NlciAtLT4gUjEKICBCcm93c2VyIC0tPiBSMgo="}),e[4]||(e[4]=i('<h2 id="_3-renderer-里最重要的几条线程-不要把-主线程-神化" tabindex="-1">3. Renderer 里最重要的几条线程：不要把“主线程”神化 <a class="header-anchor" href="#_3-renderer-里最重要的几条线程-不要把-主线程-神化" aria-label="Permalink to &quot;3. Renderer 里最重要的几条线程：不要把“主线程”神化&quot;">​</a></h2><p>前端视角里的“主线程”，在 Chromium 里更准确是 renderer 的 main thread：它要同时承担 V8 的 JS 执行，以及 Blink 生命周期里的大量工作（style/layout/paint）。</p><p>除此之外，renderer 里常见还有：</p><ul><li>Compositor thread：cc 的实现线程（impl thread），负责合成调度与 draw</li><li>Raster worker threads：瓦片栅格化（raster）相关工作线程池</li><li>Worker threads：Dedicated/Shared Worker 的线程（属于 renderer 的一部分，但不在 main thread）</li></ul><p>一个很常见的误判是：把问题都归结为“主线程忙”。实际上很多掉帧也可能来自：</p><ul><li>合成线程被同步点卡住（commit/activate 等）</li><li>栅格化吞吐不足（瓦片/纹理预算压力）</li><li>GPU 进程或驱动路径抖动（swap/overlay/command submission）</li></ul><h2 id="_4-mojo-进程之间怎么说话" tabindex="-1">4. Mojo：进程之间怎么说话 <a class="header-anchor" href="#_4-mojo-进程之间怎么说话" aria-label="Permalink to &quot;4. Mojo：进程之间怎么说话&quot;">​</a></h2><p>Chromium 大量进程间通信（IPC）使用 Mojo。你不需要掌握 Mojo 的接口细节，但需要理解一个事实：</p><ul><li>跨进程必然引入排队、调度、序列化/反序列化的成本</li><li>跨进程同步点越多，“偶发卡一下”越容易从概率事件变成稳定复现</li></ul><p>所以很多优化最终都会落到一件事：<strong>减少跨边界的高频同步</strong>。</p><h2 id="_5-viz-为什么你总能在渲染相关讨论里看到它" tabindex="-1">5. Viz：为什么你总能在渲染相关讨论里看到它 <a class="header-anchor" href="#_5-viz-为什么你总能在渲染相关讨论里看到它" aria-label="Permalink to &quot;5. Viz：为什么你总能在渲染相关讨论里看到它&quot;">​</a></h2><p>你可以把 Viz 理解为 Chromium 的“合成与显示中枢”（表述会随版本/平台变化）：它负责把一个或多个 renderer 产出的结果在最终阶段拼装成屏幕上的画面，并对接显示系统。</p><p>从前端映射上，它解释了两件事：</p><ul><li>为什么多 renderer 的页面仍然能正确合成、正确遮挡、正确 clip</li><li>为什么“合成层面很省”有时仍然会在最后的 present/swap 上掉链子</li></ul><h2 id="_6-如何把这些边界映射到你熟悉的工具" tabindex="-1">6. 如何把这些边界映射到你熟悉的工具 <a class="header-anchor" href="#_6-如何把这些边界映射到你熟悉的工具" aria-label="Permalink to &quot;6. 如何把这些边界映射到你熟悉的工具&quot;">​</a></h2><p>建议建立三件“肌肉记忆”：</p><ul><li>DevTools Performance：先看 Main、Compositor、Raster、GPU 哪条更像瓶颈</li><li>Tracing/Perfetto：需要跨线程/跨进程钉死因果链时再上</li><li>chrome://gpu：确认当前机器与浏览器的 GPU feature、driver 状态与关键开关</li></ul><p>你越早把归因从“猜”变成“看见”，越早能从口水战进入工程讨论。</p><h2 id="_7-小结-这一章你应该带走的三句话" tabindex="-1">7. 小结：这一章你应该带走的三句话 <a class="header-anchor" href="#_7-小结-这一章你应该带走的三句话" aria-label="Permalink to &quot;7. 小结：这一章你应该带走的三句话&quot;">​</a></h2><ul><li>Chromium 的第一性不是“快”，而是“隔离”：安全与稳定决定了多进程边界</li><li>多进程之后，性能问题天然会变成“同步点问题”</li><li>任何优化建议都应该能回答：它削减的是哪条线程/哪个阶段/哪个同步点的成本</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>Chromium docs（架构入口）<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/" target="_blank" rel="noreferrer">https://chromium.googlesource.com/chromium/src/+/main/docs/</a></li><li>Site Isolation（概念入口）<a href="https://www.chromium.org/Home/chromium-security/site-isolation/" target="_blank" rel="noreferrer">https://www.chromium.org/Home/chromium-security/site-isolation/</a></li><li>Life of A Pixel（像素的一生）<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit" target="_blank" rel="noreferrer">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit</a></li></ul>',22))])}const A=t(m,[["render",n]]);export{b as __pageData,A as default};
