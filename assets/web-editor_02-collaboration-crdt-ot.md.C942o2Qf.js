import{_ as p,C as c,c as h,o as r,j as l,a2 as i,b as s,a as t,w as e,G as n,a3 as d}from"./chunks/framework.C2eRlmqf.js";const g=JSON.parse('{"title":"协同编辑：CRDT vs OT 的工程取舍（以及富文本的坑）","description":"","frontmatter":{"title":"协同编辑：CRDT vs OT 的工程取舍（以及富文本的坑）","date":"2026-01-19T00:00:00.000Z","categories":"study","tags":["web-editor","collaboration","crdt","ot","consistency"]},"headers":[],"relativePath":"web-editor/02-collaboration-crdt-ot.md","filePath":"web-editor/02-collaboration-crdt-ot.md","lastUpdated":1769026429000}'),u={name:"web-editor/02-collaboration-crdt-ot.md"};function m(b,a,A,E,T,f){const o=c("Mermaid");return r(),h("div",null,[a[2]||(a[2]=l("div",{class:"alert read-stats",role:"note"},[l("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),l("span",{class:"read-stats__text"},[t("本文约 "),l("b",null,"3538"),t(" 字，阅读预计耗时 "),l("b",null,"9"),t(" 分钟。")])],-1)),a[3]||(a[3]=l("div",{class:"alert ai-disclosure",role:"note"},[l("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),l("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),a[4]||(a[4]=i('<p>协同编辑最可怕的地方不是算法难，而是算法一旦“能跑”，你就开始和富文本语义、网络、持久化、回放性能、以及人类的编辑习惯正面肉搏。</p><h2 id="问题-为什么-文本协同-做得不错-一到富文本就开始翻车" tabindex="-1">问题：为什么“文本协同”做得不错，一到富文本就开始翻车？ <a class="header-anchor" href="#问题-为什么-文本协同-做得不错-一到富文本就开始翻车" aria-label="Permalink to &quot;问题：为什么“文本协同”做得不错，一到富文本就开始翻车？&quot;">​</a></h2><p>纯文本协同的冲突语义比较“单一”：插入/删除字符，最多再加个光标位置。</p><p>富文本不一样：</p><ul><li>文档是树结构（段落/列表/表格/内联节点）</li><li>操作带语义（拆分段落、包裹节点、改变 mark）</li><li>冲突不再是“字符层”，而是“结构层 + 属性层”</li></ul><p>所以别被“CRDT/OT 二选一”误导了，真正的问题是：<strong>你选择哪一种“事实表达”作为协同的底座</strong>，以及它能不能承受富文本的语义复杂度。</p><h2 id="分析-ot-与-crdt-的抽象层级-至少两层" tabindex="-1">分析：OT 与 CRDT 的抽象层级（至少两层） <a class="header-anchor" href="#分析-ot-与-crdt-的抽象层级-至少两层" aria-label="Permalink to &quot;分析：OT 与 CRDT 的抽象层级（至少两层）&quot;">​</a></h2><p>我用两层来解释：</p><ol><li>协议层（Protocol Layer）：怎么让多端最终一致（eventual consistency）</li><li>语义层（Semantic Layer）：怎么让结果“符合人类直觉”（intent preservation）</li></ol><h3 id="同步架构图-源文件-assets-diagrams-collaboration-architecture-mmd" tabindex="-1">同步架构图（源文件：<code>../assets/diagrams/collaboration-architecture.mmd</code>） <a class="header-anchor" href="#同步架构图-源文件-assets-diagrams-collaboration-architecture-mmd" aria-label="Permalink to &quot;同步架构图（源文件：`../assets/diagrams/collaboration-architecture.mmd`）&quot;">​</a></h3>',10)),(r(),s(d,null,{default:e(()=>[n(o,{id:"mermaid-55",class:"mermaid",graph:"sequenceDiagram%0A%20%20participant%20A%20as%20Client%20A%0A%20%20participant%20S%20as%20Sync%20Service%0A%20%20participant%20B%20as%20Client%20B%0A%0A%20%20A-%3E%3EA%3A%20local%20apply(op)%0A%20%20A-%3E%3ES%3A%20push(op%2C%20version)%0A%20%20S-%3E%3ES%3A%20validate%20%26%20persist%3Cbr%2F%3E(compact%2Fsnapshot%20if%20needed)%0A%20%20S-%3E%3EB%3A%20broadcast(op)%0A%20%20B-%3E%3EB%3A%20integrate(op)%3Cbr%2F%3E(OT%20transform%20or%20CRDT%20merge)%0A%20%20Note%20over%20A%2CB%3A%20%E5%9B%9E%E6%94%BE%E4%B8%8E%E6%8E%92%E9%9A%9C%E7%9A%84%E2%80%9C%E4%BA%8B%E5%AE%9E%E2%80%9D%E6%98%AF%20op%20log%3Cbr%2F%3E%E8%80%8C%E4%B8%8D%E6%98%AF%20DOM%0A"})]),fallback:e(()=>[...a[0]||(a[0]=[t(" Loading... ",-1)])]),_:1})),a[5]||(a[5]=i('<h3 id="ot-operational-transformation" tabindex="-1">OT（Operational Transformation） <a class="header-anchor" href="#ot-operational-transformation" aria-label="Permalink to &quot;OT（Operational Transformation）&quot;">​</a></h3><ul><li>协议层：依赖 transform 函数，把并发操作变换到同一坐标系</li><li>语义层：理论上能做意图保持，但富文本结构操作的 transform 极难写对</li><li>工程取向：更常见于“服务端权威”（centralized），由服务端保证顺序与变换</li></ul><h3 id="crdt-conflict-free-replicated-data-types" tabindex="-1">CRDT（Conflict-free Replicated Data Types） <a class="header-anchor" href="#crdt-conflict-free-replicated-data-types" aria-label="Permalink to &quot;CRDT（Conflict-free Replicated Data Types）&quot;">​</a></h3><ul><li>协议层：让操作满足可交换（commutative），通过数学结构保证最终一致</li><li>语义层：对富文本常需要更复杂的 CRDT（sequence + tree + attributes）</li><li>工程取向：更偏“去中心化”（decentralized），但工程落地仍常需要服务端做广播/持久化</li></ul><p>四舍五入：OT 更像“交通警察”（中心化调度），CRDT 更像“修路规则”（让车自己能汇入不撞车）。但富文本这条路坑太多，你总得装监控、设限速、出事故能回放。</p><h2 id="横向比较-主流方案-工程维度" tabindex="-1">横向比较：主流方案（工程维度） <a class="header-anchor" href="#横向比较-主流方案-工程维度" aria-label="Permalink to &quot;横向比较：主流方案（工程维度）&quot;">​</a></h2><table tabindex="0"><thead><tr><th>维度</th><th>OT（典型：ShareDB/自研 OT）</th><th>CRDT（典型：Yjs/Automerge）</th></tr></thead><tbody><tr><td>一致性保证</td><td>依赖 transform 正确性</td><td>依赖数据结构性质</td></tr><tr><td>服务端角色</td><td>通常强权威</td><td>可弱化，但持久化/广播仍常见</td></tr><tr><td>富文本落地</td><td>变换函数复杂、易踩边界</td><td>需要 sequence/tree CRDT 的组合设计</td></tr><tr><td>离线/重连</td><td>需要版本控制与补洞</td><td>天然支持离线合并，但垃圾回收/压缩是坑</td></tr><tr><td>可回放与审计</td><td>容易（按顺序 replay ops）</td><td>也能，但状态可能更大，需要压缩策略</td></tr><tr><td>工程成熟度</td><td>团队能力强则很稳</td><td>生态成熟（如 Yjs），但仍需业务语义适配</td></tr></tbody></table><h2 id="解决方案-协同系统的-轮点-与落地形态" tabindex="-1">解决方案：协同系统的“轮点”与落地形态 <a class="header-anchor" href="#解决方案-协同系统的-轮点-与落地形态" aria-label="Permalink to &quot;解决方案：协同系统的“轮点”与落地形态&quot;">​</a></h2><p>协同也有轮点：</p><ul><li>轮点 1：把协同当“附加功能”（加个 ws 广播）</li><li>轮点 2：把协同当“事实表达”（op log + snapshot）</li><li>轮点 3：把协同当“可观测系统”（回放、校验、压缩、告警）</li></ul><p>我更推荐从轮点 2 起步：<strong>以操作日志为中心</strong>。理由很简单：出了问题，你得能回放。你不知道日志的重要性，直到你在凌晨两点对着一个“偶现丢字 bug”发呆。</p><h2 id="工程实践-把-ot-crdt-讲成-可推导的流程-少贴代码" tabindex="-1">工程实践：把 OT/CRDT 讲成“可推导的流程”（少贴代码） <a class="header-anchor" href="#工程实践-把-ot-crdt-讲成-可推导的流程-少贴代码" aria-label="Permalink to &quot;工程实践：把 OT/CRDT 讲成“可推导的流程”（少贴代码）&quot;">​</a></h2><p>如果把协同编辑比作“快递分拣”：</p><ul><li>OT 更像一个强势的分拣中心：所有包裹（op）要先过中心扫描（transform），中心决定它们在货架上的最终位置</li><li>CRDT 更像给每个包裹贴上不可重复的条形码（全局唯一 id），让包裹们就算乱序到达也能拼回同一条“货架序列”</li></ul><p>这两个比喻背后，分别对应两种“工程抓手”：OT 抓的是“坐标系”，CRDT 抓的是“标识与可交换性”。</p><h3 id="_1-先把操作定义清楚-纯文本是最干净的练习场" tabindex="-1">1) 先把操作定义清楚：纯文本是最干净的练习场 <a class="header-anchor" href="#_1-先把操作定义清楚-纯文本是最干净的练习场" aria-label="Permalink to &quot;1) 先把操作定义清楚：纯文本是最干净的练习场&quot;">​</a></h3><p>设当前文本为字符串 S，长度为 |S|。</p><ul><li>插入：Ins(p, x)，在位置 p 插入字符串 x</li><li>删除：Del(p, n)，从位置 p 删除 n 个字符</li></ul><p>应用规则可以写成一个很“朴素”的式子（这就是你后面所有边界条件的来源）：</p><ul><li>Apply(S, Ins(p, x)) = S[0..p) ⧺ x ⧺ S[p..|S|)</li><li>Apply(S, Del(p, n)) = S[0..p) ⧺ S[min(p+n, |S|)..|S|)</li></ul><p>边界条件不用靠代码也能写出来：</p><ul><li>p 会越界：来自旧选区/旧版本提交/并发变换后的位置漂移，所以 p 必须被钳制到 [0, |S|]</li><li>n 会过大：Del(p, n) 里 n 可能超过剩余长度，实际删除区间是 [p, min(p+n, |S|))</li><li>x 会为空：空插入应当是 no-op，否则会污染 oplog 与历史</li></ul><h3 id="_2-ot-的核心不是-变换-而是-证明你变换对了" tabindex="-1">2) OT 的核心不是“变换”，而是“证明你变换对了” <a class="header-anchor" href="#_2-ot-的核心不是-变换-而是-证明你变换对了" aria-label="Permalink to &quot;2) OT 的核心不是“变换”，而是“证明你变换对了”&quot;">​</a></h3><p>OT 的直觉是：并发导致的最大问题是“坐标系不一致”。因此引入 Transform：</p><ul><li>给定并发操作 a 与 b，计算 a′ = T(a, b)，使得</li><li>Apply(Apply(S, b), a′) 与 Apply(Apply(S, a), b′) 在语义上等价</li></ul><p>对纯文本 insert/delete，变换的本质大多是“位移”：</p><ul><li>Ins 对 Ins：如果 b 在 a 前面插入了 |x_b| 个字符，那么 a 的位置要往后挪 |x_b|</li><li>Ins 对 Del：如果 b 在 a 前面删除了 d 个字符，那么 a 的位置要往前挪 d（但最多挪到 b 的起点）</li><li>Del 对 Ins：插入会把后续区间整体右移</li><li>Del 对 Del：最麻烦的情况在重叠区间，要把重叠长度扣掉</li></ul><p>这些规则一旦进入富文本结构操作，就会变得像“给蜘蛛网打补丁”：你以为在挪坐标，其实在改变结构边界。于是 OT 在富文本上的工程难点不是“写 transform”，而是“让 transform 能覆盖你所有结构操作，并且能被验证”。</p><p>给一个更工程化的提示：别一上来就追求“完美意图保持”。先做两层防线：</p><ul><li>规则层：只允许有限集合的 op 类型（约束表达，减少变换维度）</li><li>校验层：transform 后的 op 必须过 schema 校验与边界校验，过不了就降级（例如拆成更小的 ops，或回退到服务端重算）</li></ul><h3 id="_3-ot-服务端处理流程图-你应该能在纸上复述" tabindex="-1">3) OT 服务端处理流程图：你应该能在纸上复述 <a class="header-anchor" href="#_3-ot-服务端处理流程图-你应该能在纸上复述" aria-label="Permalink to &quot;3) OT 服务端处理流程图：你应该能在纸上复述&quot;">​</a></h3>',31)),(r(),s(d,null,{default:e(()=>[n(o,{id:"mermaid-349",class:"mermaid",graph:"flowchart%20TB%0A%20%20C%5B%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BA%A4%20op%20%2B%20baseRev%5D%20--%3E%20S%5B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%5D%0A%20%20S%20--%3E%20V%5B%E6%A0%A1%E9%AA%8C%3A%20schema%2F%E8%BE%B9%E7%95%8C%2F%E6%9D%83%E9%99%90%5D%0A%20%20V%20--%3E%7C%E9%80%9A%E8%BF%87%7C%20T%5BTransform%3A%20%E5%AF%B9%E9%BD%90%E5%88%B0%E5%BD%93%E5%89%8D%20rev%5D%0A%20%20T%20--%3E%20A%5BApply%3A%20%E6%9B%B4%E6%96%B0%20doc%5D%0A%20%20A%20--%3E%20L%5BAppend%3A%20%E5%86%99%E5%85%A5%20op%20log%5D%0A%20%20L%20--%3E%20B%5BBroadcast%3A%20%E6%8E%A8%E9%80%81%E7%BB%99%E5%85%B6%E4%BB%96%E5%AE%A2%E6%88%B7%E7%AB%AF%5D%0A%20%20V%20--%3E%7C%E4%B8%8D%E9%80%9A%E8%BF%87%7C%20R%5BReject%2FRepair%3A%20%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E6%88%96%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5%5D%0A"})]),fallback:e(()=>[...a[1]||(a[1]=[t(" Loading... ",-1)])]),_:1})),a[6]||(a[6]=i('<p>注意：这个流程里真正救命的不是 transform，而是“可回放的 oplog + 可解释的拒绝/修复策略”。线上事故往往不是算法跑错，而是某类边界输入让系统“悄悄走偏”。</p><h3 id="_4-crdt-的直觉-让操作可交换-但别忘了账本会膨胀" tabindex="-1">4) CRDT 的直觉：让操作可交换，但别忘了账本会膨胀 <a class="header-anchor" href="#_4-crdt-的直觉-让操作可交换-但别忘了账本会膨胀" aria-label="Permalink to &quot;4) CRDT 的直觉：让操作可交换，但别忘了账本会膨胀&quot;">​</a></h3><p>以序列类 CRDT 为例（RGA / LSEQ / Yjs 内部也有类似的思想），你通常会看到三件事：</p><ul><li>每个插入元素有全局唯一 id（可以理解成“包裹条码”）</li><li>插入不依赖“绝对位置”，而依赖“相对锚点”（例如插在某个 id 的右边）</li><li>删除不是立刻移除，而是标记 tombstone（否则并发下你会找不到参照物）</li></ul><p>因此 CRDT 的工程账本（state）会自然长大：</p><ul><li>tombstone 越来越多</li><li>元素索引越来越大</li><li>状态传输成本越来越高</li></ul><p>也就是说：CRDT 让一致性更“省心”，但把工程压力转移到了“压缩/快照/垃圾回收/索引”上。四舍五入，你还是得做服务端与存储，只是你不再把它当成“权威变换中心”，而当成“广播+持久化+压缩工厂”。</p><h3 id="_5-富文本最容易翻车的点-结构操作不是字符操作" tabindex="-1">5) 富文本最容易翻车的点：结构操作不是字符操作 <a class="header-anchor" href="#_5-富文本最容易翻车的点-结构操作不是字符操作" aria-label="Permalink to &quot;5) 富文本最容易翻车的点：结构操作不是字符操作&quot;">​</a></h3><p>用表格举例最直观：删除一行，不等价于删除若干字符。</p><p>结构操作更像树上的重写规则：</p><ul><li>DeleteRow(i)：在 Table(rows) 上删除第 i 行</li><li>SplitParagraph：把一个段落在某个点拆成两个段落</li><li>WrapInList：把若干 block 包裹进 list 结构</li></ul><p>这些操作的“意图”是结构级的。你把它强行投影成字符层插删，会出现一种很尴尬的现象：最终一致没问题，但用户直觉完全崩溃（光标跳、表格结构坏、mark 漏掉）。</p><p>工程上常见的落地路线反而更朴素：</p><ul><li>协同的 op 表达尽量贴近编辑器的模型层（例如 ProseMirror 的 Step / JSON 形式）</li><li>统一做 schema 校验与 normalize（把脏操作修到合法结构）</li><li>把“意图保持”的期望写进产品规则：哪些并发场景允许“最后写入为准”，哪些必须做特殊合并</li></ul><h2 id="进一步-一个-表格并发-事故怎么发生-以及你怎么止血" tabindex="-1">进一步：一个“表格并发”事故怎么发生（以及你怎么止血） <a class="header-anchor" href="#进一步-一个-表格并发-事故怎么发生-以及你怎么止血" aria-label="Permalink to &quot;进一步：一个“表格并发”事故怎么发生（以及你怎么止血）&quot;">​</a></h2><p>表格是富文本协同里最容易出“直觉崩溃”的模块，因为它把两类复杂度叠在一起：</p><ul><li>结构复杂：行/列/单元格嵌套，局部操作会影响全局坐标</li><li>交互复杂：选区、合并单元格、跨行删除、粘贴填充</li></ul><p>举一个足够典型的并发场景：</p><ul><li>A：删除第 2 行（DeleteRow(2)）</li><li>B：在第 3 行第 1 列的某个单元格里插入文字（InsertText(cell(3,1), …)）</li></ul><p>如果你把它们都表达成“字符插入/删除”，你会立刻碰到一个问题：B 的坐标到底是“删行前”的第 3 行，还是“删行后”的第 3 行？</p><p>这就是富文本协同的本质：你不只是要同步内容，还要同步“坐标系”与“语义锚点”。</p><p>工程上更稳的做法是让坐标尽量锚定到结构身份，而不是锚定到纯序号：</p><ul><li>行/单元格有稳定 id（例如 rowId/cellId），操作引用 id，而不是引用 index</li><li>当结构变化发生（删行/插行/合并单元格），先更新结构映射，再去解释文本插入</li></ul><p>你可以把它类比成“高铁座位号”：</p><ul><li>index 像“从车头数第几排”，列车换编组你就乱了</li><li>id 像“车厢号+座位号”，结构变化后仍能找到锚点</li></ul><p>当然，id 也不是银弹：它会引入额外的身份管理与垃圾回收（被删掉的节点 id 怎么处理？协同里多久可以回收？）。</p><h2 id="观测与回放-协同系统的底线不是一致-而是可解释" tabindex="-1">观测与回放：协同系统的底线不是一致，而是可解释 <a class="header-anchor" href="#观测与回放-协同系统的底线不是一致-而是可解释" aria-label="Permalink to &quot;观测与回放：协同系统的底线不是一致，而是可解释&quot;">​</a></h2><p>协同系统出了问题，用户通常不会说“你的一致性证明错了”，他只会说“我刚刚那段字没了”。所以你必须能回答两件事：</p><ol><li>发生了什么：哪几条 ops 并发了？顺序是什么？谁 transform/merge 了谁？</li><li>为什么变成这样：是哪条规则导致这个结果？是产品规则允许的，还是系统 bug？</li></ol><p>建议最少保留三条“黑匣子”信息：</p><ul><li>op log：每条 op 的 id、来源客户端、逻辑时间（rev 或向量时钟）、payload 摘要</li><li>回放指标：apply 延迟、transform/merge 耗时、快照命中率、重连补洞耗时</li><li>校验信号：checksum 对账、schema 校验失败次数、normalize 修复次数</li></ul><p>四舍五入：协同不是“算法题”，它是线上系统。算法让你不容易错，但观测与回放让你即使错了也能修。</p><h2 id="性能优化与异常处理-协同的工程底线" tabindex="-1">性能优化与异常处理：协同的工程底线 <a class="header-anchor" href="#性能优化与异常处理-协同的工程底线" aria-label="Permalink to &quot;性能优化与异常处理：协同的工程底线&quot;">​</a></h2><h3 id="性能-不要让-op-log-无限长" tabindex="-1">性能：不要让 op log 无限长 <a class="header-anchor" href="#性能-不要让-op-log-无限长" aria-label="Permalink to &quot;性能：不要让 op log 无限长&quot;">​</a></h3><ul><li>快照（snapshot）：定期把状态固化，log 只保留增量窗口</li><li>压缩（compaction）：合并连续 insert、抵消 insert+delete</li><li>GC（垃圾回收）：CRDT 中 tombstone 会膨胀，必须有回收策略或分段存储</li></ul><h3 id="异常-一致性不是-最终一致-而是-可证明一致" tabindex="-1">异常：一致性不是“最终一致”，而是“可证明一致” <a class="header-anchor" href="#异常-一致性不是-最终一致-而是-可证明一致" aria-label="Permalink to &quot;异常：一致性不是“最终一致”，而是“可证明一致”&quot;">​</a></h3><ul><li>校验：服务端对客户端提交的 op 做 schema 校验、边界校验</li><li>回放：每次线上事故必须能“拿到日志 → 重放 → 定位”</li><li>观测：关键指标（op size、apply latency、reconnect time、snapshot size）</li></ul><h2 id="产品语义-你必须先决定-冲突时谁说了算" tabindex="-1">产品语义：你必须先决定“冲突时谁说了算” <a class="header-anchor" href="#产品语义-你必须先决定-冲突时谁说了算" aria-label="Permalink to &quot;产品语义：你必须先决定“冲突时谁说了算”&quot;">​</a></h2><p>很多团队在协同上翻车，并不是 OT/CRDT 选错了，而是把“语义决策”默默交给了底层算法。算法只能保证一致性，不能替你做产品选择。协同编辑最终面对的是人，而人关心的是“我输入的东西为什么变了”。</p><p>一个更务实的做法是：把冲突分成几类，并给每类冲突写出你能解释给用户听的规则。</p><ul><li><strong>同一位置的文本并发插入</strong>：允许交错，还是做“稳定排序”？稳定排序通常依赖 (clientId, clock) 的全序</li><li><strong>删除与编辑并发</strong>：删除优先，还是保留编辑？很多产品会选择“删除优先”，但要保证被删除内容可以在历史里找回</li><li><strong>结构与文本并发</strong>：例如一端把段落变成列表，另一端在段落中间输入；你要决定落点落在哪个结构里</li></ul><p>可以把“语义决策”想象成一个打分函数：对每个并发结果 r，定义一个代价 cost(r)，代价越小越符合直觉。工程上不一定真的去枚举所有 r，但这个思维方式能帮你把规则写成“可讨论、可测试”的东西。</p><h2 id="落地清单-让协同系统可上线、可扩容、可排障" tabindex="-1">落地清单：让协同系统可上线、可扩容、可排障 <a class="header-anchor" href="#落地清单-让协同系统可上线、可扩容、可排障" aria-label="Permalink to &quot;落地清单：让协同系统可上线、可扩容、可排障&quot;">​</a></h2><p>协同要上线，除了算法正确性，更关键的是把系统变成“可运维”的。下面这份清单不是为了写得漂亮，而是为了让你在凌晨两点能有抓手。</p><ul><li><strong>版本与因果</strong>：每条 op 必须带上它看见的版本（rev 或向量时钟），否则你无法解释重放顺序</li><li><strong>幂等与去重</strong>：op 必须有稳定 id，重复到达要能安全忽略</li><li><strong>分段快照</strong>：快照要能按时间分段（例如每 N 条 op 或每 M 秒），避免一次性回放过长</li><li><strong>对账与自愈</strong>：周期性 checksum 对账；不一致时允许触发“强制下发快照”作为止血手段</li><li><strong>灰度与回滚</strong>：协同协议升级必须可灰度（客户端/服务端兼容窗口），并有快速回滚路径</li></ul><p>如果你只能做一件事：优先把“对账+强制快照止血”做出来。它不优雅，但它能让你在遇到边界 bug 时把事故控制在分钟级，而不是让用户在群里集体爆炸。</p><h2 id="参考与引用" tabindex="-1">参考与引用 <a class="header-anchor" href="#参考与引用" aria-label="Permalink to &quot;参考与引用&quot;">​</a></h2><ol><li>Yjs Docs: <a href="https://docs.yjs.dev/" target="_blank" rel="noreferrer">https://docs.yjs.dev/</a> （Bib: <code>yjs_docs</code>）</li><li>Automerge Docs: <a href="https://automerge.org/" target="_blank" rel="noreferrer">https://automerge.org/</a> （Bib: <code>automerge_docs</code>）</li><li>ProseMirror Collab: <a href="https://prosemirror.net/examples/collab/" target="_blank" rel="noreferrer">https://prosemirror.net/examples/collab/</a> （Bib: <code>prosemirror_collab</code>）</li><li>ShareDB (OT) docs: <a href="https://github.com/share/sharedb" target="_blank" rel="noreferrer">https://github.com/share/sharedb</a> （Bib: <code>sharedb</code>）</li></ol>',48))])}const B=p(u,[["render",m]]);export{g as __pageData,B as default};
