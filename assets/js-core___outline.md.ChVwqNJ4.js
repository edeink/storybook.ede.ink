import{f as l,c as i,o as e,a5 as t}from"./chunks/framework.BsEAYNxL.js";const c=JSON.parse('{"title":"JavaScript 语言核心：大纲","description":"","frontmatter":{"title":"JavaScript 语言核心：大纲"},"headers":[],"relativePath":"js-core/__outline.md","filePath":"js-core/__outline.md","lastUpdated":1769026429000}'),r={name:"js-core/__outline.md"};function o(h,a,n,s,u,d){return e(),i("div",null,[...a[0]||(a[0]=[t('<blockquote><p>提示：本大纲为 AI 生成草案，仅用于后续写作与总结时的提示与结构对齐，不代表正文已开始撰写。WIP 仅用于标记“正在撰写中”的内容。</p></blockquote><h2 id="_0-写作目标" tabindex="-1">0. 写作目标 <a class="header-anchor" href="#_0-写作目标" aria-label="Permalink to &quot;0. 写作目标&quot;">​</a></h2><ul><li>目标：把 JS 的“直觉”补成“模型”，避免靠背 API 生活</li><li>口径：解释“为什么”，不仅解释“是什么”</li><li>约束：不把规范当百科背诵；用最少概念解释最多现象</li></ul><h2 id="_1-语言机制-你以为你会-其实你靠运气" tabindex="-1">1. 语言机制（你以为你会，其实你靠运气） <a class="header-anchor" href="#_1-语言机制-你以为你会-其实你靠运气" aria-label="Permalink to &quot;1. 语言机制（你以为你会，其实你靠运气）&quot;">​</a></h2><h3 id="_1-1-执行上下文与作用域" tabindex="-1">1.1 执行上下文与作用域 <a class="header-anchor" href="#_1-1-执行上下文与作用域" aria-label="Permalink to &quot;1.1 执行上下文与作用域&quot;">​</a></h3><ul><li>词法作用域：变量解析的“编译期直觉”</li><li>闭包：捕获什么、生命周期是什么、常见泄漏场景</li><li>模块作用域：ESM 与 CJS 的行为差异与迁移坑</li></ul><h3 id="_1-2-对象模型与原型" tabindex="-1">1.2 对象模型与原型 <a class="header-anchor" href="#_1-2-对象模型与原型" aria-label="Permalink to &quot;1.2 对象模型与原型&quot;">​</a></h3><ul><li>原型链：属性查找、shadowing 与性能直觉</li><li>属性描述符：writable/configurable/enumerable 的边界条件</li><li>隐藏类与 inline cache：为什么“形状稳定”会更快</li></ul><h3 id="_1-3-this、绑定与函数调用" tabindex="-1">1.3 this、绑定与函数调用 <a class="header-anchor" href="#_1-3-this、绑定与函数调用" aria-label="Permalink to &quot;1.3 this、绑定与函数调用&quot;">​</a></h3><ul><li>this 不是语法，是调用约定</li><li>bind/call/apply 与箭头函数的边界</li></ul><h2 id="_2-异步模型与事件循环" tabindex="-1">2. 异步模型与事件循环 <a class="header-anchor" href="#_2-异步模型与事件循环" aria-label="Permalink to &quot;2. 异步模型与事件循环&quot;">​</a></h2><h3 id="_2-1-事件循环的可执行模型" tabindex="-1">2.1 事件循环的可执行模型 <a class="header-anchor" href="#_2-1-事件循环的可执行模型" aria-label="Permalink to &quot;2.1 事件循环的可执行模型&quot;">​</a></h3><ul><li>宏任务/微任务：Promise/await 的行为边界与常见误解</li><li>渲染时机：浏览器的 frame、布局与任务调度</li></ul><h3 id="_2-2-浏览器-vs-node-同名-api-不同语义" tabindex="-1">2.2 浏览器 vs Node：同名 API 不同语义 <a class="header-anchor" href="#_2-2-浏览器-vs-node-同名-api-不同语义" aria-label="Permalink to &quot;2.2 浏览器 vs Node：同名 API 不同语义&quot;">​</a></h3><ul><li>定时器：最小时间片与嵌套调度</li><li>I/O：事件循环阶段与回调时序</li></ul><h2 id="_3-类型系统-从-js-到-ts-的-工程契约" tabindex="-1">3. 类型系统（从 JS 到 TS 的“工程契约”） <a class="header-anchor" href="#_3-类型系统-从-js-到-ts-的-工程契约" aria-label="Permalink to &quot;3. 类型系统（从 JS 到 TS 的“工程契约”）&quot;">​</a></h2><h3 id="_3-1-类型的价值-把-约定-变成-可检查" tabindex="-1">3.1 类型的价值：把“约定”变成“可检查” <a class="header-anchor" href="#_3-1-类型的价值-把-约定-变成-可检查" aria-label="Permalink to &quot;3.1 类型的价值：把“约定”变成“可检查”&quot;">​</a></h3><ul><li>边界：输入输出、错误处理与可组合性</li><li>重构：减少回归与隐式耦合</li></ul><h3 id="_3-2-常见陷阱-最贵的不是写类型-是写错类型" tabindex="-1">3.2 常见陷阱：最贵的不是写类型，是写错类型 <a class="header-anchor" href="#_3-2-常见陷阱-最贵的不是写类型-是写错类型" aria-label="Permalink to &quot;3.2 常见陷阱：最贵的不是写类型，是写错类型&quot;">​</a></h3><ul><li>any/unknown/never：什么场景用，什么场景禁用</li><li>泛型边界：约束、默认值与推导失败</li><li>运行时校验：类型与真实数据之间的鸿沟</li></ul><h2 id="_4-性能与运行时" tabindex="-1">4. 性能与运行时 <a class="header-anchor" href="#_4-性能与运行时" aria-label="Permalink to &quot;4. 性能与运行时&quot;">​</a></h2><h3 id="_4-1-性能直觉-热路径与形状稳定" tabindex="-1">4.1 性能直觉：热路径与形状稳定 <a class="header-anchor" href="#_4-1-性能直觉-热路径与形状稳定" aria-label="Permalink to &quot;4.1 性能直觉：热路径与形状稳定&quot;">​</a></h3><ul><li>JIT 的基本直觉：稳定输入更容易被优化</li><li>退优化：某些“看似无害”的写法让性能跳水</li></ul><h3 id="_4-2-内存与-gc-别把泄漏当成-业务增长" tabindex="-1">4.2 内存与 GC：别把泄漏当成“业务增长” <a class="header-anchor" href="#_4-2-内存与-gc-别把泄漏当成-业务增长" aria-label="Permalink to &quot;4.2 内存与 GC：别把泄漏当成“业务增长”&quot;">​</a></h3><ul><li>分配：短命对象、逃逸与频繁 GC 的触发点</li><li>泄漏：事件监听、缓存、闭包与 DOM 引用链</li><li>策略：LRU、分片、弱引用与上限治理</li></ul><h2 id="_5-典型专题-拟写文章方向" tabindex="-1">5. 典型专题（拟写文章方向） <a class="header-anchor" href="#_5-典型专题-拟写文章方向" aria-label="Permalink to &quot;5. 典型专题（拟写文章方向）&quot;">​</a></h2><ul><li>原型与隐藏类：从“查属性”到“性能模式”</li><li>事件循环：把 async/await 的时序一次讲清楚</li><li>类型与边界：用 TS 管住“可维护性”</li><li>内存与泄漏：从复现到定位的系统方法</li></ul>',27)])])}const b=l(r,[["render",o]]);export{c as __pageData,b as default};
