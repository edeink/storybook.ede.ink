import{_ as o,C as s,c as n,o as r,j as a,b as d,a2 as p,a as l,w as t,G as u,a3 as m}from"./chunks/framework.C2eRlmqf.js";const k=JSON.parse('{"title":"前端对照表：哪些写法对应哪条渲染管线","description":"","frontmatter":{"title":"前端对照表：哪些写法对应哪条渲染管线","date":"2026-01-20T00:00:00.000Z","categories":"study","tags":["browser-rendering","frontend","css","layout","paint","compositing","performance"]},"headers":[],"relativePath":"browser-rendering/09-frontend-levers-css-composite-paint-budget.md","filePath":"browser-rendering/09-frontend-levers-css-composite-paint-budget.md","lastUpdated":1769026429000}'),c={name:"browser-rendering/09-frontend-levers-css-composite-paint-budget.md"};function h(f,e,b,_,g,x){const i=s("Mermaid");return r(),n("div",null,[e[1]||(e[1]=a("div",{class:"alert read-stats",role:"note"},[a("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),a("span",{class:"read-stats__text"},[l("本文约 "),a("b",null,"681"),l(" 字，阅读预计耗时 "),a("b",null,"2"),l(" 分钟。")])],-1)),e[2]||(e[2]=a("div",{class:"alert ai-disclosure",role:"note"},[a("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),a("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),e[3]||(e[3]=a("p",null,"前端性能优化最常见的误区是“背 API”。真正更可靠的路径是：把每一个操作映射到渲染管线的某个阶段，然后用阶段语言讨论成本与收益。",-1)),e[4]||(e[4]=a("p",null,"这一章是一张对照表：你写的 JS/CSS/DOM/Canvas 到底在推高哪一段成本，以及有哪些更稳的改写方式。",-1)),e[5]||(e[5]=a("h2",{id:"_1-快速归因-先问一句-它触发了什么",tabindex:"-1"},[l("1. 快速归因：先问一句“它触发了什么” "),a("a",{class:"header-anchor",href:"#_1-快速归因-先问一句-它触发了什么","aria-label":'Permalink to "1. 快速归因：先问一句“它触发了什么”"'},"​")],-1)),e[6]||(e[6]=a("p",null,"你改了一行代码，问自己三个问题：",-1)),e[7]||(e[7]=a("ol",null,[a("li",null,"它触发 style/layout/paint 吗？"),a("li",null,"它能留在 compositor-only 吗？"),a("li",null,"它会带来更大的 raster/GPU 压力吗？")],-1)),(r(),d(m,null,{default:t(()=>[u(i,{id:"mermaid-31",class:"mermaid",graph:"flowchart%20LR%0A%20%20Change%5B%22JS%2FCSS%2FDOM%20%E6%94%B9%E5%8A%A8%22%5D%20--%3E%20Style%0A%20%20Change%20--%3E%20Layout%0A%20%20Change%20--%3E%20Paint%0A%20%20Change%20--%3E%20Composite%0A%20%20Paint%20--%3E%20Raster%0A%20%20Composite%20--%3E%20Present%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[l(" Loading... ",-1)])]),_:1})),e[8]||(e[8]=p('<h2 id="_2-典型-卡顿制造机-与替代方案" tabindex="-1">2. 典型“卡顿制造机”与替代方案 <a class="header-anchor" href="#_2-典型-卡顿制造机-与替代方案" aria-label="Permalink to &quot;2. 典型“卡顿制造机”与替代方案&quot;">​</a></h2><h3 id="_2-1-强制同步布局-layout-thrash" tabindex="-1">2.1 强制同步布局（layout thrash） <a class="header-anchor" href="#_2-1-强制同步布局-layout-thrash" aria-label="Permalink to &quot;2.1 强制同步布局（layout thrash）&quot;">​</a></h3><p>症状：</p><ul><li>读写交错，导致 forced reflow</li><li>交互路径上 frame time 尖峰</li></ul><p>替代思路：</p><ul><li>把读取集中到一批，把写入集中到一批</li><li>用缓存的测量结果替代每帧读取</li><li>能用 CSS 表达的，不要用 JS 每帧推布局</li></ul><h3 id="_2-2-大面积重绘-paint-storm" tabindex="-1">2.2 大面积重绘（paint storm） <a class="header-anchor" href="#_2-2-大面积重绘-paint-storm" aria-label="Permalink to &quot;2.2 大面积重绘（paint storm）&quot;">​</a></h3><p>症状：</p><ul><li>Paint 时间明显变长</li><li>Raster 线程忙到顶</li></ul><p>替代思路：</p><ul><li>避免大面积阴影/滤镜/复杂 clip 动态变化</li><li>用更局部的元素替代整屏效果</li><li>让动画更接近 compositor-only（但别滥用升层）</li></ul><h3 id="_2-3-合成树膨胀-layer-explosion" tabindex="-1">2.3 合成树膨胀（layer explosion） <a class="header-anchor" href="#_2-3-合成树膨胀-layer-explosion" aria-label="Permalink to &quot;2.3 合成树膨胀（layer explosion）&quot;">​</a></h3><p>症状：</p><ul><li>Compositor/Raster 压力升高</li><li>显存吃紧导致抖动</li></ul><p>替代思路：</p><ul><li>把“升层”当成策略，而不是默认</li><li>控制大纹理：避免超大 fixed 背景/超大图片同时在屏</li><li>用 content-visibility/虚拟列表减少同时存在的可见内容</li></ul><h3 id="_2-4-worker-通信税-message-tax" tabindex="-1">2.4 Worker 通信税（message tax） <a class="header-anchor" href="#_2-4-worker-通信税-message-tax" aria-label="Permalink to &quot;2.4 Worker 通信税（message tax）&quot;">​</a></h3><p>症状：</p><ul><li>主线程空了，但仍掉帧</li><li>postMessage/structured clone 占比高</li></ul><p>替代思路：</p><ul><li>拆分任务，让 Worker 产出更小、更稳定、可增量的数据</li><li>能 Transfer 就 Transfer，必要时上 SharedArrayBuffer</li><li>避免主线程等待 Worker 结果再推进（同步等待就是 jank）</li></ul><h2 id="_3-合成友好-工具箱-但要记住代价" tabindex="-1">3. “合成友好”工具箱（但要记住代价） <a class="header-anchor" href="#_3-合成友好-工具箱-但要记住代价" aria-label="Permalink to &quot;3. “合成友好”工具箱（但要记住代价）&quot;">​</a></h2><ul><li>transform/opacity 动画：倾向更容易 compositor-only</li><li>containment / content-visibility：倾向减少无效化传播与不可见内容的成本</li><li>IntersectionObserver：把“是否可见”从每帧计算变成事件驱动</li><li>ResizeObserver：比手写轮询更稳，但也要注意回调内不要强制同步读取布局</li></ul><h2 id="_4-预算-把性能变成可执行的约束" tabindex="-1">4. 预算：把性能变成可执行的约束 <a class="header-anchor" href="#_4-预算-把性能变成可执行的约束" aria-label="Permalink to &quot;4. 预算：把性能变成可执行的约束&quot;">​</a></h2><p>一个能落地的性能治理需要预算化：</p><ul><li>主线程预算：每帧留给 JS 的时间上限</li><li>渲染预算：layout/paint 的上限（尤其列表/大文档场景）</li><li>GPU 预算：纹理数量、瓦片压力、视频/画布并发量</li></ul><p>预算不是为了限制创造力，而是为了把“体感问题”变成“可复盘的工程规范”。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>Chrome DevTools Performance <a href="https://developer.chrome.com/docs/devtools/performance/" target="_blank" rel="noreferrer">https://developer.chrome.com/docs/devtools/performance/</a></li><li>A Pixel（帧管线视角）<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit" target="_blank" rel="noreferrer">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit</a></li></ul>',29))])}const y=o(c,[["render",h]]);export{k as __pageData,y as default};
