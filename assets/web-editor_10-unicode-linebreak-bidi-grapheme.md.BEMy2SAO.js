import{_ as n,C as s,c as d,o as r,j as a,a2 as l,b as c,a as i,w as t,G as p,a3 as u}from"./chunks/framework.C2eRlmqf.js";const B=JSON.parse('{"title":"Unicode 行内排版三件套：Line Break / Bidi / Grapheme Break","description":"","frontmatter":{"title":"Unicode 行内排版三件套：Line Break / Bidi / Grapheme Break","date":"2026-01-27T00:00:00.000Z","categories":"study","tags":["web-editor","unicode","typography","layout","linebreak","bidi","grapheme"]},"headers":[],"relativePath":"web-editor/10-unicode-linebreak-bidi-grapheme.md","filePath":"web-editor/10-unicode-linebreak-bidi-grapheme.md","lastUpdated":1769193553000}'),h={name:"web-editor/10-unicode-linebreak-bidi-grapheme.md"};function g(b,e,m,_,k,x){const o=s("Mermaid");return r(),d("div",null,[e[1]||(e[1]=a("div",{class:"alert read-stats",role:"note"},[a("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),a("span",{class:"read-stats__text"},[i("本文约 "),a("b",null,"2252"),i(" 字，阅读预计耗时 "),a("b",null,"6"),i(" 分钟。")])],-1)),e[2]||(e[2]=a("div",{class:"alert ai-disclosure",role:"note"},[a("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),a("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),e[3]||(e[3]=l('<p>前一篇我把“排版”拆成了 Box/Line/Rect，并把断行、增量、约束这些大骨架过了一遍（<a href="./09-layout-algorithms-constraint">09-layout-algorithms-constraint.md</a>）。 但如果你真要把“行内布局”做成可交互、可回放、可排障的工程系统，迟早会撞上三个 Unicode 级别的细则：</p><ul><li><strong>Unicode Grapheme Break</strong>：用户眼里“一次移动光标”的最小单位到底是什么</li><li><strong>Unicode Bidirectional</strong>：逻辑顺序怎么变成视觉顺序（以及怎么从视觉反查回逻辑）</li><li><strong>Unicode Line Break</strong>：哪里“允许断行”，以及哪些地方“禁止断行”</li></ul><p>它们看起来像语言学，实际上是交互成本：如果这三件事不对，你会得到一堆特别难复现、特别难解释、特别容易被用户骂的 bug：光标跳、选区裂、双击选词像抽奖、阿拉伯语/希伯来语夹英文数字直接炸。</p><p>我更愿意把这三套算法当成“行内布局的基础协议”：它们不是为了排得好看，而是为了让你能把“用户感知的字符”变成工程里可运算、可缓存、可映射的对象。</p><h2 id="_1-先把-行内布局管线-讲清楚" tabindex="-1">1) 先把“行内布局管线”讲清楚 <a class="header-anchor" href="#_1-先把-行内布局管线-讲清楚" aria-label="Permalink to &quot;1) 先把“行内布局管线”讲清楚&quot;">​</a></h2><p>把行内排版抽象成一条 pipeline，会更像工程系统而不是玄学：</p>',6)),(r(),c(u,null,{default:t(()=>[p(o,{id:"mermaid-34",class:"mermaid",graph:"flowchart%20LR%0A%20%20T%5B%E9%80%BB%E8%BE%91%E6%96%87%E6%9C%AC%3Cbr%2F%3E(code%20points)%5D%20--%3E%20G%5BGrapheme%20Segmentation%3Cbr%2F%3E(UAX%2329)%5D%0A%20%20G%20--%3E%20B%5BBidi%20Resolve%20%26%20Reorder%3Cbr%2F%3E(UAX%239)%5D%0A%20%20B%20--%3E%20S%5BShaping%3Cbr%2F%3E(OpenType%2FHarfbuzz-like)%5D%0A%20%20S%20--%3E%20L%5BLine%20Break%20Opportunities%3Cbr%2F%3E(UAX%2314)%5D%0A%20%20L%20--%3E%20W%5BWidth-fit%20%2B%20Break%20Decision%3Cbr%2F%3E(greedy%2FDP)%5D%0A%20%20W%20--%3E%20P%5BPositions%3Cbr%2F%3E(x%2C%20advance%2C%20bounds)%5D%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[i(" Loading... ",-1)])]),_:1})),e[4]||(e[4]=l(`<p>这里我刻意把“机会”和“决策”分开：</p><ul><li>UAX#29 / UAX#9 / UAX#14 更像“规则引擎”，给你一堆 <strong>可用的边界与映射</strong></li><li>真正的断行决策，仍然要回到“宽度”和“策略”（greedy/Knuth-Plass/CSS 规则）</li></ul><p>类比一下：Unicode 给你的是交通法规（哪里能掉头、哪里不能掉头），排版算法做的是导航（在法规允许范围内，怎么走最省事/最好看）。</p><h2 id="_2-grapheme-break-用户看到的-一个字符-不是代码里的一个码位" tabindex="-1">2) Grapheme Break：用户看到的“一个字符”，不是代码里的一个码位 <a class="header-anchor" href="#_2-grapheme-break-用户看到的-一个字符-不是代码里的一个码位" aria-label="Permalink to &quot;2) Grapheme Break：用户看到的“一个字符”，不是代码里的一个码位&quot;">​</a></h2><h3 id="_2-1-问题-为什么-按-utf-16-下标移动光标-一定会出事" tabindex="-1">2.1 问题：为什么“按 UTF-16 下标移动光标”一定会出事 <a class="header-anchor" href="#_2-1-问题-为什么-按-utf-16-下标移动光标-一定会出事" aria-label="Permalink to &quot;2.1 问题：为什么“按 UTF-16 下标移动光标”一定会出事&quot;">​</a></h3><p>JS 里你拿到的是 UTF-16 code units；很多“一个字符”的东西并不是一个 code unit，甚至不是一个 code point。</p><p>典型例子：</p><ul><li>Emoji：一个“家庭”表情可能是多个 emoji + ZWJ 组合出来的序列</li><li>组合附加符号：<code>e</code> + <code>◌́</code> 看起来像 <code>é</code>，但可能是两个 code points</li><li>区域旗帜：<code>🇨🇳</code> 本质是两个 Regional Indicator 组合</li></ul><p>如果你在编辑器里让光标在这些序列中间停下，用户会觉得你在“把一个字劈开”。更糟的是：你后续的 hit testing / selection mapping 也会被迫承认这种“劈开是合法状态”，那整个系统都会变脏。</p><h3 id="_2-2-不变量-把-extended-grapheme-cluster-当作交互最小单位" tabindex="-1">2.2 不变量：把 Extended Grapheme Cluster 当作交互最小单位 <a class="header-anchor" href="#_2-2-不变量-把-extended-grapheme-cluster-当作交互最小单位" aria-label="Permalink to &quot;2.2 不变量：把 Extended Grapheme Cluster 当作交互最小单位&quot;">​</a></h3><p>UAX#29 给了一个可执行的分段规则：把 code points 切成 <strong>Extended Grapheme Clusters</strong>（近似“用户感知的字符”）。</p><p>工程上我建议把它提升成一个不变量：</p><ul><li>光标移动单位：按 cluster 走，不按 code unit 走</li><li>双击选词的最小切分：先在 cluster 上做，再往上拼成 word</li><li>selection 的边界：永远落在 cluster 边界上（否则会有“半个字被选中”）</li></ul><p>类比：你可以把 code points 看成散装零件，cluster 才是用户拿在手里的“成品零件”。交互系统如果直接操作散装零件，迟早扎手。</p><h3 id="_2-3-失败场景与排障视角" tabindex="-1">2.3 失败场景与排障视角 <a class="header-anchor" href="#_2-3-失败场景与排障视角" aria-label="Permalink to &quot;2.3 失败场景与排障视角&quot;">​</a></h3><ul><li>现象：光标在 emoji 内部停住、删除一个“字”却删掉半个、撤销后光标落在奇怪位置</li><li>常见根因：存储层/选择层用 UTF-16 offset；渲染层按 cluster；两套坐标系没对齐</li><li>排障策略：把 cluster 边界可视化（每个 cluster 画一个细框），然后把 caret 只允许落在框之间</li></ul><h2 id="_3-bidirectional-逻辑顺序到视觉顺序-是一条可回放的映射链" tabindex="-1">3) Bidirectional：逻辑顺序到视觉顺序，是一条可回放的映射链 <a class="header-anchor" href="#_3-bidirectional-逻辑顺序到视觉顺序-是一条可回放的映射链" aria-label="Permalink to &quot;3) Bidirectional：逻辑顺序到视觉顺序，是一条可回放的映射链&quot;">​</a></h2><h3 id="_3-1-你真正要解决的不是-从右往左渲染-而是-双向映射" tabindex="-1">3.1 你真正要解决的不是“从右往左渲染”，而是“双向映射” <a class="header-anchor" href="#_3-1-你真正要解决的不是-从右往左渲染-而是-双向映射" aria-label="Permalink to &quot;3.1 你真正要解决的不是“从右往左渲染”，而是“双向映射”&quot;">​</a></h3><p>在编辑器里，Bidi 不是“排版风格”，而是“坐标映射问题”：</p><ul><li>输入与文档状态：通常以逻辑顺序存储（logical order）</li><li>渲染与 hit testing：发生在视觉顺序（visual order）</li><li>交互闭环：你必须能稳定地把 visual 的位置反查回 logical 的 offset</li></ul><p>只要你做过 <a href="./11-hit-testing-and-event-system">11-hit-testing-and-event-system.md</a> 这种“从坐标到文档位置”，就会发现 Bidi 是绕不开的：同一行里，x 轴上相邻的 glyph，逻辑上可能不相邻。</p><h3 id="_3-2-uax-9-的核心产物-levels-reordering-以及-isolate-时代的现实" tabindex="-1">3.2 UAX#9 的核心产物：levels + reordering（以及 isolate 时代的现实） <a class="header-anchor" href="#_3-2-uax-9-的核心产物-levels-reordering-以及-isolate-时代的现实" aria-label="Permalink to &quot;3.2 UAX#9 的核心产物：levels + reordering（以及 isolate 时代的现实）&quot;">​</a></h3><p>UAX#9（Unicode Bidirectional Algorithm）最终会给你两类关键结果：</p><ul><li>每个字符（更准确说：每个 bidi unit）的 <strong>embedding level</strong></li><li>基于 level 的 <strong>reordering</strong> 规则，得到 visual order</li></ul><p>工程上，建议你把“reordering”落实成显式数组：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>logicalIndex -&gt; visualIndex</span></span>
<span class="line"><span>visualIndex  -&gt; logicalIndex</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>它看起来朴素，但这是后面所有交互的地基：hit testing 找到的是 visualIndex，selection 要落回 logicalIndex，事务（transaction）又会让 logicalIndex 发生映射（mapping），最后你才有机会做到可回放。</p><h3 id="_3-3-失败场景与排障视角" tabindex="-1">3.3 失败场景与排障视角 <a class="header-anchor" href="#_3-3-失败场景与排障视角" aria-label="Permalink to &quot;3.3 失败场景与排障视角&quot;">​</a></h3><ul><li>现象：阿拉伯语中夹英文数字时，光标左右键方向“反直觉”；选区拖拽像磁铁一样乱跳</li><li>常见根因：只做了渲染重排，没有维护 visual/logical 映射；或者忽略 isolate（LRI/RLI/FSI/PDI）导致嵌套场景错解</li><li>排障策略：把每个 run 的 level 标在屏幕上（例如在行盒上方画 <code>0/1/2</code>），再把 visual-&gt;logical 映射打印成一条可比对的序列</li></ul><h2 id="_4-line-break-unicode-给你-断行机会-策略层决定-在哪里断" tabindex="-1">4) Line Break：Unicode 给你“断行机会”，策略层决定“在哪里断” <a class="header-anchor" href="#_4-line-break-unicode-给你-断行机会-策略层决定-在哪里断" aria-label="Permalink to &quot;4) Line Break：Unicode 给你“断行机会”，策略层决定“在哪里断”&quot;">​</a></h2><h3 id="_4-1-断行的工程分层-机会-uax-14-vs-决策-宽度与策略" tabindex="-1">4.1 断行的工程分层：机会（UAX#14） vs 决策（宽度与策略） <a class="header-anchor" href="#_4-1-断行的工程分层-机会-uax-14-vs-决策-宽度与策略" aria-label="Permalink to &quot;4.1 断行的工程分层：机会（UAX#14） vs 决策（宽度与策略）&quot;">​</a></h3><p>UAX#14（Unicode Line Breaking Algorithm）做的事情很克制：它定义了每个码位的 line break class，并给出一套规则（LBxx）判断相邻两类之间：</p><ul><li>允许断行（break opportunity）</li><li>禁止断行</li><li>必须断行（硬换行、段落分隔等）</li></ul><p>但真正的排版不会只看“允不允许”，还要看：</p><ul><li>行宽能不能放下（width fit）</li><li>CSS/产品策略：<code>word-break</code>、<code>overflow-wrap</code>、<code>line-break</code>、hyphenation</li><li>字体 shaping 后的实际 advances（有的脚本宽度不是按字符加法能算的）</li></ul><p>四舍五入：UAX#14 更像“候选集生成器”，你在它给的候选断点上跑 greedy 或 Knuth–Plass，才是编辑器里常见的落地形态。</p><h3 id="_4-2-最容易掉坑的边界条件" tabindex="-1">4.2 最容易掉坑的边界条件 <a class="header-anchor" href="#_4-2-最容易掉坑的边界条件" aria-label="Permalink to &quot;4.2 最容易掉坑的边界条件&quot;">​</a></h3><ul><li>CJK：很多场景下“字字可断”，但也有禁止断的标点组合与禁则（这会叠加到 UAX#14 与 CSS <code>line-break</code> 规则上）</li><li>空格与标点：断在空格前还是空格后，决定了你行首/行尾会不会出现奇怪的空白</li><li>超长不可断词：URL、长数字串、代码 token；你必须有兜底（overflow-wrap / 强制断 / 缩放 / 溢出显示）</li></ul><p>排障视角也很直接：把每个潜在断点可视化（例如在允许断的位置画一个小刻度），你就能一眼区分“候选集错了”还是“宽度决策错了”。</p><h2 id="_5-把三件套落到编辑器交互-你需要哪些中间结果" tabindex="-1">5) 把三件套落到编辑器交互：你需要哪些中间结果 <a class="header-anchor" href="#_5-把三件套落到编辑器交互-你需要哪些中间结果" aria-label="Permalink to &quot;5) 把三件套落到编辑器交互：你需要哪些中间结果&quot;">​</a></h2><p>把它们和前一篇的 Box/Line/Rect 对齐，会得到一组非常工程化的中间产物：</p><ul><li><strong>Clusters</strong>：Grapheme cluster 列表（用于 caret movement、删除、双击）</li><li><strong>Bidi runs</strong>：每段 run 的 level、以及 visual/logical 映射（用于 hit testing 与 selection）</li><li><strong>Break opportunities</strong>：一行内所有可断点（用于 greedy/DP 断行）</li><li><strong>Glyph runs</strong>：shaping 后的 glyph id + advance（用于从 x 反查 offset）</li></ul><p>这也是为什么我把它放在“布局算法”之后、“命中与事件系统”之前：你在命中章节里会大量使用这些中间结果，不然你的 (x,y) 只能靠猜。</p><h2 id="_6-增量更新-unicode-规则不是全局重算-但也不是局部瞎算" tabindex="-1">6) 增量更新：Unicode 规则不是全局重算，但也不是局部瞎算 <a class="header-anchor" href="#_6-增量更新-unicode-规则不是全局重算-但也不是局部瞎算" aria-label="Permalink to &quot;6) 增量更新：Unicode 规则不是全局重算，但也不是局部瞎算&quot;">​</a></h2><p>编辑器输入是增量的，所以你会自然想“只重算改动范围”。但 Unicode 分段有一个工程上的现实：很多规则依赖邻近上下文。</p><p>一个稳的策略是给每一层分段都定义一个 <strong>lookback/lookahead 窗口</strong>：</p><ul><li>Grapheme：需要看组合符号、ZWJ 序列、Regional Indicators 的连续性</li><li>Bidi：需要看 run 边界与 isolate 配对，不能只切一刀</li><li>Line Break：需要看相邻 class 组合，有些规则跨越多个码位（例如空格、标点与 combining）</li></ul><p>落地时，你可以把“脏区间”扩展成“脏区间 + 安全窗口”，只要窗口足够，你就能既增量，又可解释；窗口不够，bug 会表现为“偶现”。</p><h2 id="_7-小结-这三套算法的价值是-把交互从玄学变成协议" tabindex="-1">7) 小结：这三套算法的价值是“把交互从玄学变成协议” <a class="header-anchor" href="#_7-小结-这三套算法的价值是-把交互从玄学变成协议" aria-label="Permalink to &quot;7) 小结：这三套算法的价值是“把交互从玄学变成协议”&quot;">​</a></h2><p>如果只谈排版质量，这三件套确实显得“太底层”。 但对编辑器而言，它们的真正价值是：让你能把“字符”变成稳定的工程对象，让光标、选区、命中、回放，都落在同一套可验证的中间结果上。</p><p>下一篇（命中与事件系统）会把这些中间结果用起来：从 x 轴反查 cluster，从 visual order 落回 logical position，最终把一次点击闭环成文档事实。</p><h2 id="参考与引用" tabindex="-1">参考与引用 <a class="header-anchor" href="#参考与引用" aria-label="Permalink to &quot;参考与引用&quot;">​</a></h2><ol><li>Unicode Standard Annex #14: Unicode Line Breaking Algorithm：<a href="https://unicode.org/reports/tr14/" target="_blank" rel="noreferrer">https://unicode.org/reports/tr14/</a> （Bib: <code>unicode_uax14</code>）</li><li>Unicode Standard Annex #9: Unicode Bidirectional Algorithm：<a href="https://unicode.org/reports/tr9/" target="_blank" rel="noreferrer">https://unicode.org/reports/tr9/</a> （Bib: <code>unicode_uax9</code>）</li><li>Unicode Standard Annex #29: Unicode Text Segmentation（Grapheme Cluster）：<a href="https://unicode.org/reports/tr29/" target="_blank" rel="noreferrer">https://unicode.org/reports/tr29/</a> （Bib: <code>unicode_uax29</code>）</li><li>CSS Text Module Level 3（line-break/word-break/overflow-wrap）：<a href="https://www.w3.org/TR/css-text-3/" target="_blank" rel="noreferrer">https://www.w3.org/TR/css-text-3/</a> （Bib: <code>css_text_3</code>）</li><li>HarfBuzz（shaping 的工程入口）：<a href="https://harfbuzz.github.io/" target="_blank" rel="noreferrer">https://harfbuzz.github.io/</a> （Bib: <code>harfbuzz</code>）</li></ol>`,53))])}const v=n(h,[["render",g]]);export{B as __pageData,v as default};
