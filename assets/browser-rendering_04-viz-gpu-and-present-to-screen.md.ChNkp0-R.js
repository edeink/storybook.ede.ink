import{_ as o,C as t,c as n,o as i,j as r,b as p,a2 as u,a,w as l,G as d,a3 as c}from"./chunks/framework.C2eRlmqf.js";const y=JSON.parse('{"title":"Viz/GPU/上屏：surface、buffer 与显示路径","description":"","frontmatter":{"title":"Viz/GPU/上屏：surface、buffer 与显示路径","date":"2026-01-20T00:00:00.000Z","categories":"study","tags":["browser-rendering","chromium","viz","gpu","skia","present","vsync"]},"headers":[],"relativePath":"browser-rendering/04-viz-gpu-and-present-to-screen.md","filePath":"browser-rendering/04-viz-gpu-and-present-to-screen.md","lastUpdated":1769026429000}'),m={name:"browser-rendering/04-viz-gpu-and-present-to-screen.md"};function f(h,e,b,_,g,P){const s=t("Mermaid");return i(),n("div",null,[e[1]||(e[1]=r("div",{class:"alert read-stats",role:"note"},[r("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),r("span",{class:"read-stats__text"},[a("本文约 "),r("b",null,"861"),a(" 字，阅读预计耗时 "),r("b",null,"3"),a(" 分钟。")])],-1)),e[2]||(e[2]=r("div",{class:"alert ai-disclosure",role:"note"},[r("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),r("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),e[3]||(e[3]=r("p",null,"前端把“渲染”想成 style/layout/paint 很正常，但在 Chromium 里，真正把像素送上屏的最后一段路，往往在你不常看的地方：Viz、GPU 进程、显示系统与驱动。",-1)),e[4]||(e[4]=r("p",null,"这一章不追求源码级别的细节完整，而是把关键概念和因果链讲清楚：为什么你已经把主线程优化到很干净，仍然会遇到掉帧与抖动。",-1)),e[5]||(e[5]=r("h2",{id:"_1-从-cc-到-viz-compositorframe-不是-像素-而是-如何得到像素",tabindex:"-1"},[a("1. 从 cc 到 Viz：CompositorFrame 不是“像素”，而是“如何得到像素” "),r("a",{class:"header-anchor",href:"#_1-从-cc-到-viz-compositorframe-不是-像素-而是-如何得到像素","aria-label":'Permalink to "1. 从 cc 到 Viz：CompositorFrame 不是“像素”，而是“如何得到像素”"'},"​")],-1)),e[6]||(e[6]=r("p",null,"cc 产出的 CompositorFrame 更像一种描述：",-1)),e[7]||(e[7]=r("ul",null,[r("li",null,"哪些 surface 要组合"),r("li",null,"哪些 draw quads 要画"),r("li",null,"哪些资源（纹理/图像/瓦片）需要引用")],-1)),e[8]||(e[8]=r("p",null,"把它类比成“渲染指令包”比“位图”更贴切。",-1)),(i(),p(c,null,{default:l(()=>[d(s,{id:"mermaid-34",class:"mermaid",graph:"flowchart%20LR%0A%20%20CC%5B%22cc%EF%BC%88Renderer%EF%BC%89%22%5D%20--%3E%20Frame%5B%22CompositorFrame%22%5D%0A%20%20Frame%20--%3E%20Viz%5B%22Viz%EF%BC%88Display%20compositor%EF%BC%89%22%5D%0A%20%20Viz%20--%3E%20GPU%5B%22GPU%20process%20%2F%20Driver%22%5D%0A%20%20GPU%20--%3E%20OS%5B%22OS%20Compositor%20%2F%20Display%20system%22%5D%0A%20%20OS%20--%3E%20Screen%5B%22Screen%22%5D%0A"})]),fallback:l(()=>[...e[0]||(e[0]=[a(" Loading... ",-1)])]),_:1})),e[9]||(e[9]=u('<h2 id="_2-surface-跨进程合成的拼装单位" tabindex="-1">2. Surface：跨进程合成的拼装单位 <a class="header-anchor" href="#_2-surface-跨进程合成的拼装单位" aria-label="Permalink to &quot;2. Surface：跨进程合成的拼装单位&quot;">​</a></h2><p>当一个页面存在多个 renderer（比如跨站 iframe），最终的合成必须跨进程完成。Surface 是一个很实用的抽象：</p><ul><li>每个 renderer 可以输出自己的 surface（或一组 surface）</li><li>Viz 负责把它们组合成最终屏幕画面</li></ul><p>从前端角度，这解释了很多“多 iframe 性能怪现象”：你看到的最终一帧，可能来自多个进程的产出与同步。</p><h2 id="_3-buffer-与-swap-vsync-节拍下的最后交卷" tabindex="-1">3. Buffer 与 swap：Vsync 节拍下的最后交卷 <a class="header-anchor" href="#_3-buffer-与-swap-vsync-节拍下的最后交卷" aria-label="Permalink to &quot;3. Buffer 与 swap：Vsync 节拍下的最后交卷&quot;">​</a></h2><p>屏幕刷新是按 Vsync 节拍进行的。浏览器要做的是在某个时间点之前把下一帧准备好，然后 swap/present。</p><p>掉帧经常发生在两类原因上：</p><ul><li>你没在截止时间前交卷（CPU/GPU 任何一段拖后腿都可能）</li><li>你交了卷，但显示系统/驱动没能按预期把它呈现出来（平台相关）</li></ul><p>所以“帧率问题”在底层经常不是某一个函数慢，而是整条 pipeline 的调度与排队。</p><h2 id="_4-overlay-为什么有时会突然变丝滑-或突然变糟" tabindex="-1">4. Overlay：为什么有时会突然变丝滑（或突然变糟） <a class="header-anchor" href="#_4-overlay-为什么有时会突然变丝滑-或突然变糟" aria-label="Permalink to &quot;4. Overlay：为什么有时会突然变丝滑（或突然变糟）&quot;">​</a></h2><p>Overlay（硬件叠加）粗暴理解是：某些内容不经过完整的合成流程，直接由显示硬件叠加到最终画面上。</p><p>它的直觉收益很大：</p><ul><li>省掉一段合成与拷贝</li><li>对视频这类内容尤其有价值</li></ul><p>但它高度平台相关，也受限于很多条件（格式、变换、裁剪、透明叠加等）。因此你可能会观察到一些“看起来玄学”的现象：同样页面在不同机器上表现差异巨大，根子可能在 overlay 路径是否可用。</p><h2 id="_5-纹理预算-你以为是内存-其实是-能不能持续产帧" tabindex="-1">5. 纹理预算：你以为是内存，其实是“能不能持续产帧” <a class="header-anchor" href="#_5-纹理预算-你以为是内存-其实是-能不能持续产帧" aria-label="Permalink to &quot;5. 纹理预算：你以为是内存，其实是“能不能持续产帧”&quot;">​</a></h2><p>现代网页里会抢显存的东西很多：</p><ul><li>图片与解码后的位图</li><li>Canvas / OffscreenCanvas 的 backing store</li><li>视频帧</li><li>字形缓存（glyph atlas）</li><li>过度 layerization 带来的额外纹理</li></ul><p>当纹理预算吃紧时，系统会出现很具体的症状：</p><ul><li>瓦片频繁换入换出（栅格化压力升高）</li><li>合成阶段需要等待资源（同步点增多）</li><li>GPU 进程排队加剧（整体延迟上升）</li></ul><p>前端看到的结果就是：滚动卡、动画抖、偶发掉帧。</p><h2 id="_6-前端怎么把-上屏问题-抓出来" tabindex="-1">6. 前端怎么把“上屏问题”抓出来 <a class="header-anchor" href="#_6-前端怎么把-上屏问题-抓出来" aria-label="Permalink to &quot;6. 前端怎么把“上屏问题”抓出来&quot;">​</a></h2><p>建议你把“最后一公里”当成一个独立的排障对象：</p><ul><li>DevTools Performance：观察 GPU/Compositor/Raster 的时间比例</li><li>chrome://gpu：核对 feature status、driver 信息</li><li>Tracing/Perfetto：确认 frame submission / presentation 的节奏是否稳定</li></ul><p>如果主线程很干净但仍掉帧，十有八九需要把视野扩大到 Viz/GPU。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>Chromium docs（Viz 相关入口）<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/" target="_blank" rel="noreferrer">https://chromium.googlesource.com/chromium/src/+/main/docs/</a></li><li>A Pixel（上屏节拍与系统视角）<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit" target="_blank" rel="noreferrer">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit</a></li></ul>',26))])}const C=o(m,[["render",f]]);export{y as __pageData,C as default};
