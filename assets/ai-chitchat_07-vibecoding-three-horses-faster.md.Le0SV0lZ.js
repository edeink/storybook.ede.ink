import{f as r,D as o,c as n,o as s,k as i,a4 as t,H as p,a}from"./chunks/framework.BAs4fWuZ.js";const m=JSON.parse('{"title":"AI 碎碎念 07：从 Vibe Coding 到 Spec-Driven Dev：四个轮子复刻 Faster","description":"","frontmatter":{"title":"AI 碎碎念 07：从 Vibe Coding 到 Spec-Driven Dev：四个轮子复刻 Faster","date":"2026-01-21T00:00:00.000Z","categories":"study","tags":["ai-chitchat","vibecoding","spec-driven-dev","testing","documentation","modularization","engineering"]},"headers":[],"relativePath":"ai-chitchat/07-vibecoding-three-horses-faster.md","filePath":"ai-chitchat/07-vibecoding-three-horses-faster.md","lastUpdated":1769193553000}'),d={name:"ai-chitchat/07-vibecoding-three-horses-faster.md"};function c(h,e,u,v,g,b){const l=o("InkMermaidBlock");return s(),n("div",null,[e[0]||(e[0]=i("div",{class:"alert read-stats",role:"note"},[i("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),i("span",{class:"read-stats__text"},[a("本文约 "),i("b",null,"2778"),a(" 字，阅读预计耗时 "),i("b",null,"7"),a(" 分钟。")])],-1)),e[1]||(e[1]=i("div",{class:"alert ai-disclosure",role:"note"},[i("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),i("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),e[2]||(e[2]=t('<p>我把我们以前的 Faster（<a href="https://faster.bytedance.net" target="_blank" rel="noreferrer">https://faster.bytedance.net</a>）复刻了一遍。复刻的过程给我最强烈的体感是：AI 的上下文不足不是“用不用”的问题，而是“你愿不愿意为它设计一套能持续工作的工程机制”。</p><p>如果你不做这层机制，AI 就像一个记性很差但手很快的同学：写得出代码，但经常忘了项目里已经有什么、约定是什么、改动会不会把别的东西弄坏。它带来的不是生产力，而是熵增。</p><p>但如果你把机制搭起来，熵增反而不是问题：AI 用得好，项目有机会比“古法编程（手搓一切）”更有序——前提是你真的懂，并且愿意把关键约束写进系统里。</p><p>这篇我想先把两个概念拆开讲清楚：<strong>Vibe Coding</strong> 和 <strong>Spec-Driven Development（SDD）</strong> 不是对立阵营，而是两个阶段的两种姿势。然后再把我复刻 Faster 时最依赖的“三驾马车”升级成“<strong>四个轮子</strong>”：让车跑得快，更要跑得稳，还得能跑远。</p><h2 id="_1-ai-的天然劣势-上下文窗口就是-货车载重" tabindex="-1">1. AI 的天然劣势：上下文窗口就是“货车载重” <a class="header-anchor" href="#_1-ai-的天然劣势-上下文窗口就是-货车载重" aria-label="Permalink to &quot;1. AI 的天然劣势：上下文窗口就是“货车载重”&quot;">​</a></h2><p>我更愿意把上下文窗口理解成“货车载重”，不是“智力上限”。</p><ul><li>载重不够：你没法把整个项目一次性塞进对话里</li><li>路况还变：你今天讲过的约定，明天开新对话就没了</li><li>司机还会脑补：它会在缺信息时用“看起来合理”的话补齐</li></ul><p>所以当项目变成“中等规模”（比如 Faster 这种体量），你会遇到一个结构性问题：你不可能指望 AI 永远“记得住”项目全貌，只能让它“每次都拿到它应该拿到的东西”。</p><p>这也是前三个轮子要解决的第一个问题：把上下文从“聊天记录”迁移到“工程资产”。</p><h2 id="_2-先理解差别-vibe-coding-vs-spec-driven-dev" tabindex="-1">2. 先理解差别：Vibe Coding vs Spec-Driven Dev <a class="header-anchor" href="#_2-先理解差别-vibe-coding-vs-spec-driven-dev" aria-label="Permalink to &quot;2. 先理解差别：Vibe Coding vs Spec-Driven Dev&quot;">​</a></h2><p>我以前写这类总结时，容易把它们揉成一句话：“先写规矩再让 AI 写代码”。现在我更愿意把它拆开：那不是纯粹的 Vibe Coding，而是更接近 SDD（或者说：从 Vibe 过渡到 SDD）。</p><h3 id="_2-1-vibe-coding-先把东西跑起来-接受-先粗后细" tabindex="-1">2.1 Vibe Coding：先把东西跑起来，接受“先粗后细” <a class="header-anchor" href="#_2-1-vibe-coding-先把东西跑起来-接受-先粗后细" aria-label="Permalink to &quot;2.1 Vibe Coding：先把东西跑起来，接受“先粗后细”&quot;">​</a></h3><p>Vibe Coding 的直觉非常直白：你给出意图，AI 直接开工，你顺着结果不断纠偏。极端一点就是：你“完全交给 vibe”，甚至“忘了代码存在”（Karpathy 的原话是 “fully give in to the vibes, forget that the code even exists.”）。</p><p>它更像探索期的驾驶模式：先开上路，再看导航怎么修正。适合：</p><ul><li>demo / 原型 / 绿地项目</li><li>需求还不稳、你也不知道自己到底要什么</li><li>你愿意用“推倒重来”的方式换速度</li></ul><h3 id="_2-2-spec-driven-dev-先把信息流钉住-避免-边写边偏航" tabindex="-1">2.2 Spec-Driven Dev：先把信息流钉住，避免“边写边偏航” <a class="header-anchor" href="#_2-2-spec-driven-dev-先把信息流钉住-避免-边写边偏航" aria-label="Permalink to &quot;2.2 Spec-Driven Dev：先把信息流钉住，避免“边写边偏航”&quot;">​</a></h3><p>SDD 的核心不是“写很多文档”，而是把<strong>规格（spec）当成一份可执行的合同</strong>：先明确目标、约束、验收口径，再驱动 AI 去拆解、实现、验证。</p><p>它更像收敛期的驾驶模式：你先把路线、限速、站点写清楚，后面才敢让车队并行跑。适合：</p><ul><li>需求牵涉多个系统/多人协作/棕地代码库</li><li>正确性与回归成本很高（钱、合规、数据、稳定性）</li><li>你需要可追溯：为什么这么做、出了问题怎么复盘</li></ul><h3 id="_2-3-一个更实用的结论-不是二选一-而是-先-vibe-后-spec" tabindex="-1">2.3 一个更实用的结论：不是二选一，而是“先 vibe，后 spec” <a class="header-anchor" href="#_2-3-一个更实用的结论-不是二选一-而是-先-vibe-后-spec" aria-label="Permalink to &quot;2.3 一个更实用的结论：不是二选一，而是“先 vibe，后 spec”&quot;">​</a></h3><p>我现在更认同一种折中：<strong>用 Vibe Coding 探路，用 SDD 立法</strong>。具体来说：</p>',21)),p(l,{codeBase64:"Zmxvd2NoYXJ0IExSCiAgQVvmhI/lm74v5oOz5rOVPGJyLz5WaWJlXSAtLT4gQlvlv6vpgJ/ljp/lnos8YnIvPuiDvei3keWwseihjF0KICBCIC0tPiBDW+WPkeeOsOe6puadn+S4juWdkTxici8+5oCn6IO9L+i+ueeVjC/mlbDmja5dCiAgQyAtLT4gRFvlhpkgU3BlYzxici8+55uu5qCHL+e6puadny/pqozmlLZdCiAgRCAtLT4gRVvku7vliqHmi4bop6MgKyDku6PnoIHnlJ/miJBdCiAgRSAtLT4gRlvmtYvor5Xpl6jnpoEgKyDlm57lvZJdCiAgRiAtLT4gR1vokL3mlofmoaPkuI7lhrPnrZborrDlvZVdCiAgRyAtLT4gQwo="}),e[3]||(e[3]=t('<p>换句话说：Vibe Coding 的价值在“把未知变已知”；SDD 的价值在“把已知变可复用”。两者连起来，才是一个能在中等以上项目里长期工作的姿势。</p><h2 id="_3-第-1-个轮子-模块化-把上下文隔离开-代码层" tabindex="-1">3. 第 1 个轮子：模块化，把上下文隔离开（代码层） <a class="header-anchor" href="#_3-第-1-个轮子-模块化-把上下文隔离开-代码层" aria-label="Permalink to &quot;3. 第 1 个轮子：模块化，把上下文隔离开（代码层）&quot;">​</a></h2><p>模块化在 Vibe Coding 里不只是“代码好看”，而是一种对抗上下文不足的生存策略。</p><p>你可以把它类比成船舱设计：每个舱室都要能关上舱门。哪怕某个舱室进水，也不至于整条船都沉。</p><p>落实到工程里就是：</p><ul><li>每个模块要有明确的边界：输入、输出、职责、错误处理</li><li>模块之间尽量通过稳定协议通信：类型、接口、schema，而不是“靠默契”</li><li>模块内部允许快速迭代：但对外承诺要尽量稳定</li></ul><p>Vibe Coding 反过来会强迫你做这件事：因为你跨上下文工作时，最怕的就是“牵一发动全身”。模块边界越清晰，你越敢让 AI 在某个模块里“放开写”，也越容易在复核时快速定位改动影响范围。</p><h2 id="_4-第-2-个轮子-文档-规格-把项目-放到硬盘里" tabindex="-1">4. 第 2 个轮子：文档/规格，把项目“放到硬盘里” <a class="header-anchor" href="#_4-第-2-个轮子-文档-规格-把项目-放到硬盘里" aria-label="Permalink to &quot;4. 第 2 个轮子：文档/规格，把项目“放到硬盘里”&quot;">​</a></h2><p>当你需要跨上下文窗口、跨对话、甚至跨设备工作时，文档就不再是“锦上添花”，而是“项目的外置记忆”。</p><p>我更喜欢把它叫做“项目说明书”，它回答的不是“写了什么”，而是：</p><ul><li>目标是什么：这个模块/这个项目到底要解决什么问题</li><li>约束是什么：哪些是硬约束（性能、兼容、安全），哪些是软偏好（代码风格）</li><li>决策是什么：为什么这么设计，而不是另外一种</li><li>验收是什么：什么叫做对，什么叫做错</li></ul><p>文档一旦稳定下来，它就成为你给 AI 的“长期上下文”。你开新对话也不怕，因为你可以把说明书当作入场券：先对齐约束，再开始写。</p><p>在复刻 Faster 的过程中，我明显感受到：当说明书清楚时，AI 的输出会更像“在一条轨道上加速”；当说明书模糊时，AI 的输出就像“在草地上飙车”，快，但方向不确定。</p><h2 id="_5-第-3-个轮子-单测-门禁-让熵增变成可控的噪声" tabindex="-1">5. 第 3 个轮子：单测/门禁，让熵增变成可控的噪声 <a class="header-anchor" href="#_5-第-3-个轮子-单测-门禁-让熵增变成可控的噪声" aria-label="Permalink to &quot;5. 第 3 个轮子：单测/门禁，让熵增变成可控的噪声&quot;">​</a></h2><p>很多人把单测理解成“防 bug”，但在 Vibe Coding 里它更像“防走样”。</p><p>你可以把它类比成乐谱：演奏者换了（换成 AI）、排练次数变了（多轮生成）、甚至乐器变了（不同模型/不同提示词），只要乐谱不变，旋律就不会跑太偏。</p><p>单测的价值在这里非常现实：</p><ul><li>你可以放心让 AI 反复重构：因为它一旦改坏了，立刻会被测出来</li><li>你可以把关键细节写成“可回归”的用例：别让它变成口头约定</li><li>你可以跨时间复盘：几个月后再看，也能知道当时的边界条件是什么</li></ul><p>复刻 Faster 这种中等项目时，“写得快”不是难点，“写得稳”才是难点。单测是把“稳”做成机制的最低成本方式。</p><h2 id="_6-为什么前三个轮子能对抗熵增" tabindex="-1">6. 为什么前三个轮子能对抗熵增 <a class="header-anchor" href="#_6-为什么前三个轮子能对抗熵增" aria-label="Permalink to &quot;6. 为什么前三个轮子能对抗熵增&quot;">​</a></h2><p>软件工程的迭代天生会熵增：功能堆叠、临时修补、人员流动、需求变化，都会把项目推向更无序的状态。</p><p>前三个轮子的组合，刚好分别对冲三类熵增来源：</p><ul><li>模块化：对冲“改动扩散”，把混乱锁在局部</li><li>文档：对冲“信息丢失”，把口头约定变成可复用资产</li><li>单测：对冲“质量漂移”，把正确性变成可验证的约束</li></ul><p>它们叠加起来，会形成一种很实用的效果：你不再害怕换模型、换对话、换人接手——因为项目的秩序不依赖某个人的记忆，而依赖工程资产本身。</p><h2 id="_7-第-4-个轮子-资深工程师的角色上移——更像产品-架构师" tabindex="-1">7. 第 4 个轮子：资深工程师的角色上移——更像产品 + 架构师 <a class="header-anchor" href="#_7-第-4-个轮子-资深工程师的角色上移——更像产品-架构师" aria-label="Permalink to &quot;7. 第 4 个轮子：资深工程师的角色上移——更像产品 + 架构师&quot;">​</a></h2><p>这一轮变化里，我觉得最容易被低估的，不是“AI 写代码快”，而是：<strong>资深研发终于有机会从繁琐的底层实现里抽离出来，把主要精力放回到高维度的事情上</strong>。</p><p>古法编程里，很多“资深工程师的时间”会被两类事情吃掉：</p><ul><li>低价值的搬运：样板代码、接口对齐、胶水逻辑、重复重构</li><li>沟通损耗的翻译：把意图翻译成实现细节、再把实现细节翻译回意图</li></ul><p>新时代的写法更像是：你盯住“系统会不会跑偏”，把“手上的活”交给 AI。</p><ul><li>你要像产品一样：把目标、用户价值、验收口径写清楚</li><li>你要像架构师一样：把边界、依赖、演进路线、回滚策略设计清楚</li><li>你还要像总工一样：把质量门禁、可观测性、排障路径兜住</li></ul><p>更具体一点，我觉得“高屋建瓴”在这里不是喊口号，而是把拆解顺序倒过来：先从用户价值与验收口径出发，再落到系统边界与数据流，再落到模块接口与不变量，最后才是具体实现与重构。这套顺序一旦对齐，AI 生成的代码就更像“在轨道上铺路”，而不是“在草地上撒种子”。</p><p>这其实就是我把“三驾马车”升级成“四个轮子”的原因：前三个轮子解决的是“AI 时代的工程机制”，第四个轮子解决的是“AI 时代的人怎么更值钱”。</p><h2 id="_8-常见翻车点-越写越快-还是越写越乱" tabindex="-1">8. 常见翻车点：越写越快，还是越写越乱？ <a class="header-anchor" href="#_8-常见翻车点-越写越快-还是越写越乱" aria-label="Permalink to &quot;8. 常见翻车点：越写越快，还是越写越乱？&quot;">​</a></h2><p>这套方法论不是“买了就能开”。我踩过的坑大概集中在这几类：</p><ul><li>只 vibe 不落 spec：短期爽，但需求一变就开始补丁摞补丁，最后谁也说不清“对”是什么</li><li>spec 写得太早：你把未知当已知，写下了错误约束，AI 会很听话地把你带进错误的隧道</li><li>文档只写“做了什么”：对齐不了目标/约束/验收，只会变成“项目流水账”，对下一次对话帮助不大</li><li>单测不稳定或不分层：回归噪声太大，门禁变成摆设，最终你会选择“先过了再说”</li><li>模块边界含糊：接口不稳定、职责不清晰，AI 会把改动扩散到全仓库，复核成本立刻爆炸</li></ul><p>我的补救策略也很朴素：先允许自己短期 vibe 探路，但一旦发现“会反复发生的坑”，就立刻把它写进 spec / 用例 / 约束里，变成工程资产。</p><h2 id="_9-结语-vibe-是油门-spec-是方向盘-四个轮子是底盘" tabindex="-1">9. 结语：Vibe 是油门，Spec 是方向盘，四个轮子是底盘 <a class="header-anchor" href="#_9-结语-vibe-是油门-spec-是方向盘-四个轮子是底盘" aria-label="Permalink to &quot;9. 结语：Vibe 是油门，Spec 是方向盘，四个轮子是底盘&quot;">​</a></h2><p>当这四个轮子跑起来，你能明显感觉到自己从重复劳动里抽身：</p><ul><li>你把精力更多放在任务拆解、边界定义、验收标准</li><li>把机械性的编码、搬运、重写交给 AI</li><li>把“靠谱不靠谱”的问题交给单测和文档去兜底</li></ul><p>所以我才会半开玩笑地说：Vibe Coding 是我的救世主、再生父母。</p><p>但这个玩笑背后有一句更严肃的话：它救的不是“代码”，而是我作为工程师的注意力与自信。</p><h2 id="参考与引用" tabindex="-1">参考与引用 <a class="header-anchor" href="#参考与引用" aria-label="Permalink to &quot;参考与引用&quot;">​</a></h2><ol><li>Andrej Karpathy, “vibe coding” 原始定义（X）：<a href="https://x.com/karpathy/status/1886192184808149383" target="_blank" rel="noreferrer">https://x.com/karpathy/status/1886192184808149383</a></li><li>Augment Code, Vibe Coding &amp; Spec-Driven Dev（信息流视角与组合用法）：<a href="https://www.augmentcode.com/guides/ai-prompting-techniques-vibe-coding-spec-driven-dev" target="_blank" rel="noreferrer">https://www.augmentcode.com/guides/ai-prompting-techniques-vibe-coding-spec-driven-dev</a></li><li>GitHub, Spec Kit（SDD 的开源工具链与“spec 作为 source of truth”）：<a href="https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/" target="_blank" rel="noreferrer">https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/</a></li><li>Thoughtworks Technology Radar, Spec-driven development（SDD 作为新兴工作流的边界与风险提示）：<a href="https://www.thoughtworks.com/en-us/radar/techniques/spec-driven-development" target="_blank" rel="noreferrer">https://www.thoughtworks.com/en-us/radar/techniques/spec-driven-development</a></li></ol>',43))])}const A=r(d,[["render",c]]);export{m as __pageData,A as default};
