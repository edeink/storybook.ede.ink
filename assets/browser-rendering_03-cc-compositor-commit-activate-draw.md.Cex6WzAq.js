import{_ as p,C as m,c as d,o as i,j as e,a2 as o,b as s,a as r,w as t,G as c,a3 as n}from"./chunks/framework.C2eRlmqf.js";const b=JSON.parse('{"title":"cc 合成体系：两棵树、属性树与同步点","description":"","frontmatter":{"title":"cc 合成体系：两棵树、属性树与同步点","date":"2026-01-20T00:00:00.000Z","categories":"study","tags":["browser-rendering","chromium","compositor","cc","layers","animation","scrolling"]},"headers":[],"relativePath":"browser-rendering/03-cc-compositor-commit-activate-draw.md","filePath":"browser-rendering/03-cc-compositor-commit-activate-draw.md","lastUpdated":1769026429000}'),u={name:"browser-rendering/03-cc-compositor-commit-activate-draw.md"};function _(h,a,C,f,A,E){const l=m("Mermaid");return i(),d("div",null,[a[2]||(a[2]=e("div",{class:"alert read-stats",role:"note"},[e("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),e("span",{class:"read-stats__text"},[r("本文约 "),e("b",null,"1036"),r(" 字，阅读预计耗时 "),e("b",null,"3"),r(" 分钟。")])],-1)),a[3]||(a[3]=e("div",{class:"alert ai-disclosure",role:"note"},[e("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),e("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),a[4]||(a[4]=o('<p>如果 Blink 负责把网页“翻译成可绘制的中间表示”，那么 cc（compositor）负责把这些中间表示组织成“一帧可以上屏的东西”。对前端而言，cc 解释了两类最常见的现象：</p><ul><li>为什么有些动画很丝滑（哪怕主线程有点忙）</li><li>为什么有些卡顿很顽固（你以为只是 JS，实际卡在同步点）</li></ul><h2 id="_1-合成到底合的是什么-树、属性与帧" tabindex="-1">1. 合成到底合的是什么：树、属性与帧 <a class="header-anchor" href="#_1-合成到底合的是什么-树、属性与帧" aria-label="Permalink to &quot;1. 合成到底合的是什么：树、属性与帧&quot;">​</a></h2><p>合成不是“把像素拼起来”这么简单。cc 的核心工作更像是：</p><ul><li>把页面拆成层（layerization）</li><li>维护一套描述视觉状态的属性树（transform/clip/effect/scroll）</li><li>按 Vsync 节拍生成可提交的一帧（CompositorFrame）</li></ul>',5)),(i(),s(n,null,{default:t(()=>[c(l,{id:"mermaid-40",class:"mermaid",graph:"flowchart%20LR%0A%20%20Blink%5B%22Blink%20main%20thread%3Cbr%2F%3Estyle%2Flayout%2Fpaint%22%5D%20--%3E%7Ccommit%7C%20CC%5B%22cc%20compositor%20thread%3Cbr%2F%3Eimpl%22%5D%0A%20%20CC%20--%3E%7Craster%20tasks%7C%20Raster%5B%22Raster%20workers%22%5D%0A%20%20Raster%20--%3E%20CC%0A%20%20CC%20--%3E%7Csubmit%20frame%7C%20Viz%5B%22Viz%20%2F%20Display%20compositor%22%5D%0A"})]),fallback:t(()=>[...a[0]||(a[0]=[r(" Loading... ",-1)])]),_:1})),a[5]||(a[5]=o('<h2 id="_2-两棵树-pending-与-active" tabindex="-1">2. 两棵树：Pending 与 Active <a class="header-anchor" href="#_2-两棵树-pending-与-active" aria-label="Permalink to &quot;2. 两棵树：Pending 与 Active&quot;">​</a></h2><p>cc 常被描述成“两棵树”的结构（具体命名与实现会演进），其意义在于：<strong>当前用于 draw 的状态与最新提交的状态可以并存</strong>。</p><ul><li>Pending tree：主线程最新提交的状态（还未生效）</li><li>Active tree：正在用于 draw 的状态（保证可持续产帧）</li></ul><p>这套设计是为了让系统在高负载时仍能“尽量持续产帧”，而不是每次更新都把自己卡死。</p><h2 id="_3-三个关键同步点-commit-activate-draw" tabindex="-1">3. 三个关键同步点：Commit / Activate / Draw <a class="header-anchor" href="#_3-三个关键同步点-commit-activate-draw" aria-label="Permalink to &quot;3. 三个关键同步点：Commit / Activate / Draw&quot;">​</a></h2><p>前端很多“偶发卡顿”，最终都可以在这三个阶段里找到一个硬拐点：</p><ul><li>commit：主线程把最新的渲染状态提交给合成线程</li><li>activate：pending 切换为 active（真正生效）</li><li>draw：生成并提交一帧</li></ul>',7)),(i(),s(n,null,{default:t(()=>[c(l,{id:"mermaid-85",class:"mermaid",graph:"sequenceDiagram%0A%20%20participant%20Main%20as%20Main%20thread%EF%BC%88Blink%2BV8%EF%BC%89%0A%20%20participant%20Impl%20as%20Compositor%20thread%EF%BC%88cc%EF%BC%89%0A%20%20participant%20Raster%20as%20Raster%20workers%0A%20%20Main-%3E%3EImpl%3A%20Commit%EF%BC%88state%20%2B%20paint%EF%BC%89%0A%20%20Impl-%3E%3EImpl%3A%20Build%2FUpdate%20property%20trees%0A%20%20Impl-%3E%3ERaster%3A%20Schedule%20raster%EF%BC%88tiles%EF%BC%89%0A%20%20Raster--%3E%3EImpl%3A%20Raster%20done%0A%20%20Impl-%3E%3EImpl%3A%20Activate%EF%BC%88pending%20-%3E%20active%EF%BC%89%0A%20%20Impl-%3E%3EImpl%3A%20Draw%EF%BC%88produce%20frame%EF%BC%89%0A"})]),fallback:t(()=>[...a[1]||(a[1]=[r(" Loading... ",-1)])]),_:1})),a[6]||(a[6]=o('<p>排障直觉是：如果卡在 commit/activate，很多时候不是“算不动”，而是“同步点太硬”。你可能需要减少提交频率、减少层复杂度、减少需要重栅格化的面积，或者把某些更新变成 compositor-only。</p><h2 id="_4-property-trees-transform-clip-effect-scroll-为什么要单独成树" tabindex="-1">4. Property Trees：transform/clip/effect/scroll 为什么要单独成树 <a class="header-anchor" href="#_4-property-trees-transform-clip-effect-scroll-为什么要单独成树" aria-label="Permalink to &quot;4. Property Trees：transform/clip/effect/scroll 为什么要单独成树&quot;">​</a></h2><p>很多前端习惯把“层级关系”全部归因到 DOM 树或 layer 树，但合成阶段需要的是另一种关系：视觉属性的继承与组合。</p><p>属性树把几类视觉属性拆出来管理：</p><ul><li>Transform tree：变换矩阵的层级组合</li><li>Clip tree：裁剪区域的层级组合</li><li>Effect tree：透明度、滤镜等效果的层级组合</li><li>Scroll tree：滚动相关的状态与关联</li></ul><p>这样做的收益是：当某个属性变化时，能更局部地更新状态，并更容易走 compositor-only 路径。</p><h2 id="_5-compositor-only-的边界-丝滑来自-避开主线程-不是魔法" tabindex="-1">5. Compositor-only 的边界：丝滑来自“避开主线程”，不是魔法 <a class="header-anchor" href="#_5-compositor-only-的边界-丝滑来自-避开主线程-不是魔法" aria-label="Permalink to &quot;5. Compositor-only 的边界：丝滑来自“避开主线程”，不是魔法&quot;">​</a></h2><p>对前端最实用的结论是：</p><ul><li>transform/opacity 的变化更容易在合成线程完成</li><li>layout/paint 相关的变化基本绕不开主线程（以及后续 raster）</li></ul><p>但要同时记住代价：</p><ul><li>让更多东西变成独立 layer，会带来显存与栅格化压力</li><li>layer 多到一定程度，你会把瓶颈从 main thread 推到 raster/GPU</li></ul><p>因此“升层优化”的正确姿势是：把它当作一种 trade-off，而不是万能钥匙。</p><h2 id="_6-滚动-为什么浏览器要努力把它从主线程搬走" tabindex="-1">6. 滚动：为什么浏览器要努力把它从主线程搬走 <a class="header-anchor" href="#_6-滚动-为什么浏览器要努力把它从主线程搬走" aria-label="Permalink to &quot;6. 滚动：为什么浏览器要努力把它从主线程搬走&quot;">​</a></h2><p>滚动是最容易暴露延迟的交互：用户手指/滚轮一动，下一帧没跟上就会被立刻感知。</p><p>Chromium 会尽量让滚动走 compositor thread（impl-thread scrolling），其核心动机是：</p><ul><li>主线程可能在跑 JS、在 layout、在 paint</li><li>滚动如果强依赖主线程，就会稳定掉帧</li></ul><p>这也是为什么某些页面“主线程再忙也能滚”，而另一些页面“滚一下就卡住”：它们是否能走 compositor 友好的滚动路径不同。</p><h2 id="_7-小结-把-cc-当成-帧调度系统" tabindex="-1">7. 小结：把 cc 当成“帧调度系统” <a class="header-anchor" href="#_7-小结-把-cc-当成-帧调度系统" aria-label="Permalink to &quot;7. 小结：把 cc 当成“帧调度系统”&quot;">​</a></h2><p>如果把 Blink 看成“把网页变成可画数据”，那么 cc 更像“按节拍交卷的帧调度系统”。你写的前端代码最终会变成两类成本：</p><ul><li>main thread 的生命周期成本（style/layout/paint + JS/GC）</li><li>cc 的帧调度与同步点成本（commit/activate/draw + raster/GPU）</li></ul><p>前端优化的很多争论，四舍五入都是在讨论：我们到底在削哪一类成本，以及把它挪到哪一边更划算。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>Chromium docs（渲染/合成相关入口）<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/" target="_blank" rel="noreferrer">https://chromium.googlesource.com/chromium/src/+/main/docs/</a></li><li>A Pixel（合成与上屏节拍）<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit" target="_blank" rel="noreferrer">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit</a></li></ul>',23))])}const y=p(u,[["render",_]]);export{b as __pageData,y as default};
