import{f as l,c as e,o as i,a4 as t}from"./chunks/framework.BAs4fWuZ.js";const c=JSON.parse('{"title":"数据结构与算法：大纲","description":"","frontmatter":{"title":"数据结构与算法：大纲"},"headers":[],"relativePath":"ds-algorithms/__outline.md","filePath":"ds-algorithms/__outline.md","lastUpdated":1769026429000}'),r={name:"ds-algorithms/__outline.md"};function o(h,a,n,u,d,s){return i(),e("div",null,[...a[0]||(a[0]=[t('<blockquote><p>提示：本大纲为 AI 生成草案，仅用于后续写作与总结时的提示与结构对齐，不代表正文已开始撰写。WIP 仅用于标记“正在撰写中”的内容。</p></blockquote><h2 id="_0-写作原则" tabindex="-1">0. 写作原则 <a class="header-anchor" href="#_0-写作原则" aria-label="Permalink to &quot;0. 写作原则&quot;">​</a></h2><ul><li>目标：讲清楚边界条件、复杂度与工程常数项，避免“会背不会用”</li><li>方法：每个结构/算法都绑定一个真实工程场景与失败案例</li></ul><h2 id="_1-常用结构-工程视角" tabindex="-1">1. 常用结构（工程视角） <a class="header-anchor" href="#_1-常用结构-工程视角" aria-label="Permalink to &quot;1. 常用结构（工程视角）&quot;">​</a></h2><h3 id="_1-1-线性结构-看似简单-坑在局部性" tabindex="-1">1.1 线性结构：看似简单，坑在局部性 <a class="header-anchor" href="#_1-1-线性结构-看似简单-坑在局部性" aria-label="Permalink to &quot;1.1 线性结构：看似简单，坑在局部性&quot;">​</a></h3><ul><li>数组：cache-friendly、扩容策略、内存碎片与拷贝成本</li><li>链表：指针追踪的代价、迭代与随机访问的边界</li><li>栈/队列/双端队列：调度、滑动窗口与生产者消费者</li></ul><h3 id="_1-2-哈希与集合-平均-o-1-的代价是什么" tabindex="-1">1.2 哈希与集合：平均 O(1) 的代价是什么 <a class="header-anchor" href="#_1-2-哈希与集合-平均-o-1-的代价是什么" aria-label="Permalink to &quot;1.2 哈希与集合：平均 O(1) 的代价是什么&quot;">​</a></h3><ul><li>哈希表：装载因子、rehash、冲突、攻击面与防护</li><li>布隆过滤器：误判率、内存预算、典型落地（缓存穿透）</li></ul><h3 id="_1-3-树与索引-工程世界的-秩序" tabindex="-1">1.3 树与索引：工程世界的“秩序” <a class="header-anchor" href="#_1-3-树与索引-工程世界的-秩序" aria-label="Permalink to &quot;1.3 树与索引：工程世界的“秩序”&quot;">​</a></h3><ul><li>平衡树：红黑树/AVL 的直觉差异（旋转次数 vs 查询稳定性）</li><li>B+Tree：为什么磁盘/SSD 时代更偏向 B+Tree</li><li>跳表：并发友好与实现复杂度的平衡点</li></ul><h3 id="_1-4-区间与空间索引-范围查询的利器" tabindex="-1">1.4 区间与空间索引：范围查询的利器 <a class="header-anchor" href="#_1-4-区间与空间索引-范围查询的利器" aria-label="Permalink to &quot;1.4 区间与空间索引：范围查询的利器&quot;">​</a></h3><ul><li>Interval Tree / Segment Tree：装饰器范围、时间区间、命中检测</li><li>R-Tree / Grid：2D hit testing、空间对象查询</li></ul><h3 id="_1-5-并发与无锁结构-可选深水区" tabindex="-1">1.5 并发与无锁结构（可选深水区） <a class="header-anchor" href="#_1-5-并发与无锁结构-可选深水区" aria-label="Permalink to &quot;1.5 并发与无锁结构（可选深水区）&quot;">​</a></h3><ul><li>ABA、内存模型与可见性</li><li>无锁队列/环形队列：吞吐与延迟的取舍</li></ul><h2 id="_2-常用算法" tabindex="-1">2. 常用算法 <a class="header-anchor" href="#_2-常用算法" aria-label="Permalink to &quot;2. 常用算法&quot;">​</a></h2><h3 id="_2-1-二分与变体-最容易写错的-最基础算法" tabindex="-1">2.1 二分与变体：最容易写错的“最基础算法” <a class="header-anchor" href="#_2-1-二分与变体-最容易写错的-最基础算法" aria-label="Permalink to &quot;2.1 二分与变体：最容易写错的“最基础算法”&quot;">​</a></h3><ul><li>边界：lower_bound / upper_bound 的统一模板</li><li>单调性：把问题改写成单调 predicate</li><li>失败案例：溢出、死循环、浮点边界、离散化错误</li></ul><h3 id="_2-2-排序与选择-复杂度之外还有常数项" tabindex="-1">2.2 排序与选择：复杂度之外还有常数项 <a class="header-anchor" href="#_2-2-排序与选择-复杂度之外还有常数项" aria-label="Permalink to &quot;2.2 排序与选择：复杂度之外还有常数项&quot;">​</a></h3><ul><li>稳定性：业务语义依赖稳定排序的典型场景</li><li>局部性：为什么 TimSort 在真实世界常赢</li><li>TopK：堆、quickselect、分桶与流式场景</li></ul><h2 id="_3-真实问题" tabindex="-1">3. 真实问题 <a class="header-anchor" href="#_3-真实问题" aria-label="Permalink to &quot;3. 真实问题&quot;">​</a></h2><h3 id="_3-1-编辑器-把-文本-当成结构化数据" tabindex="-1">3.1 编辑器：把“文本”当成结构化数据 <a class="header-anchor" href="#_3-1-编辑器-把-文本-当成结构化数据" aria-label="Permalink to &quot;3.1 编辑器：把“文本”当成结构化数据&quot;">​</a></h3><ul><li>文档存储：Rope / Piece Table 的取舍与边界</li><li>位置映射：变更后的 position mapping 与装饰器范围更新</li><li>hit testing：从像素回查位置的索引结构</li></ul><h3 id="_3-2-性能与工程-算法只是上限-系统决定下限" tabindex="-1">3.2 性能与工程：算法只是上限，系统决定下限 <a class="header-anchor" href="#_3-2-性能与工程-算法只是上限-系统决定下限" aria-label="Permalink to &quot;3.2 性能与工程：算法只是上限，系统决定下限&quot;">​</a></h3><ul><li>缓存策略：LRU/LFU、失效策略、击穿/雪崩</li><li>分帧与增量：预算化计算、避免主线程长任务</li><li>数据结构选择：常数项、内存占用、实现复杂度</li></ul><h2 id="_4-拟发布文章方向" tabindex="-1">4. 拟发布文章方向 <a class="header-anchor" href="#_4-拟发布文章方向" aria-label="Permalink to &quot;4. 拟发布文章方向&quot;">​</a></h2><ul><li>二分的工程模板：把边界条件一次讲清楚</li><li>红黑树/B+Tree/跳表：同一个“有序集合”的三种成本模型</li><li>区间索引：Interval Tree 在编辑器/渲染系统里的落地</li><li>Rope/Piece Table：文本编辑的底层事实与回放能力</li></ul>',26)])])}const b=l(r,[["render",o]]);export{c as __pageData,b as default};
