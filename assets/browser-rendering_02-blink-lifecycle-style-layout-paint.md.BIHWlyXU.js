import{f as n,D as r,c as s,o as d,k as i,a5 as a,H as o,a as e}from"./chunks/framework.BsEAYNxL.js";const _=JSON.parse('{"title":"Blink 生命周期：style/layout/paint 与无效化","description":"","frontmatter":{"title":"Blink 生命周期：style/layout/paint 与无效化","date":"2026-01-20T00:00:00.000Z","categories":"study","tags":["browser-rendering","chromium","blink","style","layout","paint","invalidation"]},"headers":[],"relativePath":"browser-rendering/02-blink-lifecycle-style-layout-paint.md","filePath":"browser-rendering/02-blink-lifecycle-style-layout-paint.md","lastUpdated":1769026429000}'),c={name:"browser-rendering/02-blink-lifecycle-style-layout-paint.md"};function p(u,l,m,h,b,g){const t=r("InkMermaidBlock");return d(),s("div",null,[l[0]||(l[0]=i("div",{class:"alert read-stats",role:"note"},[i("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),i("span",{class:"read-stats__text"},[e("本文约 "),i("b",null,"1055"),e(" 字，阅读预计耗时 "),i("b",null,"3"),e(" 分钟。")])],-1)),l[1]||(l[1]=i("div",{class:"alert ai-disclosure",role:"note"},[i("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),i("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),l[2]||(l[2]=a('<p>这一章讨论的是“网页描述（DOM/CSS）”如何在 Blink 里变成“可画的东西”。它也是前端性能优化里最核心的一段：你写的每一次 DOM/CSS 改动，最终都会落到这里的某些阶段上。</p><h2 id="_1-先把不变量写出来-blink-到底要产出什么" tabindex="-1">1. 先把不变量写出来：Blink 到底要产出什么 <a class="header-anchor" href="#_1-先把不变量写出来-blink-到底要产出什么" aria-label="Permalink to &quot;1. 先把不变量写出来：Blink 到底要产出什么&quot;">​</a></h2><p>把细节抽象掉，Blink 在一次渲染更新里要完成两类输出：</p><ul><li>几何：每个盒子在哪里、多大、怎么滚动/裁剪</li><li>绘制：把哪些东西画出来、按什么顺序画、哪些能复用缓存</li></ul><p>对应到熟悉的词，就是：</p><ul><li>style：算出计算后的样式（computed style）</li><li>layout：算出几何（layout result / fragments）</li><li>paint：生成绘制中间产物（paint artifact / display items）</li></ul>',6)),o(t,{codeBase64:"Zmxvd2NoYXJ0IExSCiAgRE9NWyJET00gLyBDU1NPTSJdIC0tPiBTdHlsZVsiU3R5bGUgcmVjYWxjPGJyLz5zZWxlY3RvciBtYXRjaCArIGNhc2NhZGUiXQogIFN0eWxlIC0tPiBMYXlvdXRbIkxheW91dDxici8+Z2VvbWV0cnkgKyBmcmFnbWVudHMiXQogIExheW91dCAtLT4gUGFpbnRbIlBhaW50PGJyLz5kaXNwbGF5IGl0ZW1zIC8gcGFpbnQgYXJ0aWZhY3QiXQogIFBhaW50IC0tPiBDQ1siY2MgY29tbWl0PGJyLz5sYXllcml6YXRpb24gLyBwcm9wZXJ0eSB0cmVlcyJdCg=="}),l[3]||(l[3]=a('<h2 id="_2-为什么-无效化-invalidation-比算法更重要" tabindex="-1">2. 为什么“无效化（invalidation）”比算法更重要 <a class="header-anchor" href="#_2-为什么-无效化-invalidation-比算法更重要" aria-label="Permalink to &quot;2. 为什么“无效化（invalidation）”比算法更重要&quot;">​</a></h2><p>前端经常把优化等价成“把 layout 算法变快”。但真实世界里，更常见的关键是：<strong>不要让不该参与的人参与</strong>。</p><p>Blink 要回答的问题不是“怎么算”，而是“哪些需要重新算”：</p><ul><li>style invalidation：哪些元素的 computed style 变了</li><li>layout invalidation：哪些盒子的几何需要重排</li><li>paint invalidation：哪些区域需要重绘</li></ul><p>你可以把它类比成增量编译：每次代码改动都全量编译当然慢，真正的速度来自“最小受影响集合”。</p><h2 id="_3-style-选择器匹配只是开始-真正的战场是缓存与依赖" tabindex="-1">3. Style：选择器匹配只是开始，真正的战场是缓存与依赖 <a class="header-anchor" href="#_3-style-选择器匹配只是开始-真正的战场是缓存与依赖" aria-label="Permalink to &quot;3. Style：选择器匹配只是开始，真正的战场是缓存与依赖&quot;">​</a></h2><p>从前端视角看，style 阶段主要成本往往来自：</p><ul><li>选择器匹配与级联（尤其是复杂选择器、深层 DOM）</li><li>依赖传播：字体、媒体查询、容器查询、伪类状态等</li><li>无效化范围：某些 class 切换可能导致大范围重新计算</li></ul><p>工程上常见的“意外扩大”包括：</p><ul><li>把某个会频繁变动的 class 挂在高层容器上，导致子树大面积 style invalidation</li><li>使用会触发全树匹配的选择器模式（例如某些复杂的后代选择器组合）</li></ul><h2 id="_4-layout-读一个属性-可能就把整条管线拉回来" tabindex="-1">4. Layout：读一个属性，可能就把整条管线拉回来 <a class="header-anchor" href="#_4-layout-读一个属性-可能就把整条管线拉回来" aria-label="Permalink to &quot;4. Layout：读一个属性，可能就把整条管线拉回来&quot;">​</a></h2><p>layout 阶段的第一性矛盾是：很多前端代码喜欢“读完再写，写完再读”。</p><p>当你读取某些布局相关信息（典型：<code>offsetWidth/getBoundingClientRect</code>），浏览器为了保证返回值正确，可能会在此刻强制把 pending 的 style/layout 计算补齐。这就是常说的强制同步布局（layout flush / layout thrash）。</p><p>典型危险模式：</p><ol><li>读布局</li><li>写 DOM（导致无效化）</li><li>再读布局</li><li>循环多次</li></ol>',15)),o(t,{codeBase64:"c2VxdWVuY2VEaWFncmFtCiAgcGFydGljaXBhbnQgSlMgYXMgSlPvvIhtYWluIHRocmVhZO+8iQogIHBhcnRpY2lwYW50IEJsaW5rIGFzIEJsaW5rIGxpZmVjeWNsZQogIEpTLT4+Qmxpbms6IHdyaXRlIERPTSAvIGNsYXNzTGlzdAogIE5vdGUgb3ZlciBCbGluazogbWFyayBkaXJ0ee+8iHN0eWxlL2xheW91dO+8iQogIEpTLT4+Qmxpbms6IHJlYWQgbGF5b3V077yIZ2V0Qm91bmRpbmdDbGllbnRSZWN077yJCiAgQmxpbmstLT4+SlM6IGZvcmNlIGZsdXNo77yIc3R5bGUrbGF5b3V077yJCiAgSlMtPj5CbGluazogd3JpdGUgRE9NIGFnYWluCiAgSlMtPj5CbGluazogcmVhZCBsYXlvdXQgYWdhaW4KICBCbGluay0tPj5KUzogZm9yY2UgZmx1c2ggYWdhaW7vvIjmipbliqjvvIkK"}),l[4]||(l[4]=a('<p>如果你只记住一个技巧：把读布局与写布局分成批次，尽量不要交错。</p><h2 id="_5-paint-你以为是-画一下-其实是生成可复用的中间产物" tabindex="-1">5. Paint：你以为是“画一下”，其实是生成可复用的中间产物 <a class="header-anchor" href="#_5-paint-你以为是-画一下-其实是生成可复用的中间产物" aria-label="Permalink to &quot;5. Paint：你以为是“画一下”，其实是生成可复用的中间产物&quot;">​</a></h2><p>paint 阶段并不是直接把像素画到屏幕上，它更像是：</p><ul><li>生成绘制列表（display items）</li><li>构建可缓存的绘制中间产物（paint artifact）</li><li>记录无效区域（invalidations）供后续栅格化复用</li></ul><p>这也是为什么一些“看起来没动”的 CSS，可能会让 paint 成本暴增：</p><ul><li>阴影、滤镜、半透明叠加</li><li>复杂路径、频繁变化的 clip</li><li>大面积重绘（尤其高分屏下像素数爆炸）</li></ul><h2 id="_6-从-blink-到-cc-什么时候会-升层" tabindex="-1">6. 从 Blink 到 cc：什么时候会“升层” <a class="header-anchor" href="#_6-从-blink-到-cc-什么时候会-升层" aria-label="Permalink to &quot;6. 从 Blink 到 cc：什么时候会“升层”&quot;">​</a></h2><p>从主线程产出的 paint 结果，会在后续阶段被用于合成（compositing）。</p><p>前端常见的误区是把“layer”当成免费午餐：升层可能让某些动画走合成线程更顺，但也可能带来：</p><ul><li>更多纹理（显存占用）</li><li>更多栅格化瓦片（raster 压力）</li><li>更复杂的合成树（commit/activate 同步点压力）</li></ul><p>所以更靠谱的口径是：把升层当作一种“把成本从 main thread 挪到 raster/gpu 的选择”，并不等于成本消失。</p><h2 id="_7-这一章的排障清单-偏工程" tabindex="-1">7. 这一章的排障清单（偏工程） <a class="header-anchor" href="#_7-这一章的排障清单-偏工程" aria-label="Permalink to &quot;7. 这一章的排障清单（偏工程）&quot;">​</a></h2><ul><li>style 很贵：先怀疑 invalidation 范围是不是太大</li><li>layout 很贵：先排查有没有 forced reflow（读写交错）</li><li>paint 很贵：先看是否大面积重绘、是否有昂贵的视觉效果</li><li>结论要落到“哪个阶段变贵、为什么变贵”，而不是一句“页面很卡”</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>Chromium docs（Blink 相关入口）<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/" target="_blank" rel="noreferrer">https://chromium.googlesource.com/chromium/src/+/main/docs/</a></li><li>A Pixel（渲染主线视角）<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit" target="_blank" rel="noreferrer">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit</a></li><li>Web Browser Engineering（用可跑的实现理解管线）<a href="https://browser.engineering/" target="_blank" rel="noreferrer">https://browser.engineering/</a></li></ul>',15))])}const k=n(c,[["render",p]]);export{_ as __pageData,k as default};
