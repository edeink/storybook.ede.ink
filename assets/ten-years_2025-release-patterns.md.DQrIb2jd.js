import{_ as p,C as u,c as h,o as i,j as e,a2 as d,b as o,a as l,w as a,G as s,a3 as n}from"./chunks/framework.C2eRlmqf.js";const b=JSON.parse('{"title":"四种发版节奏对比","description":"","frontmatter":{"title":"四种发版节奏对比"},"headers":[],"relativePath":"ten-years/2025-release-patterns.md","filePath":"ten-years/2025-release-patterns.md","lastUpdated":1769193553000}'),E={name:"ten-years/2025-release-patterns.md"};function f(c,t,m,A,B,_){const r=u("Mermaid");return i(),h("div",null,[t[2]||(t[2]=e("div",{class:"alert read-stats",role:"note"},[e("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),e("span",{class:"read-stats__text"},[l("本文约 "),e("b",null,"2420"),l(" 字，阅读预计耗时 "),e("b",null,"7"),l(" 分钟。")])],-1)),t[3]||(t[3]=e("div",{class:"alert ai-disclosure",role:"note"},[e("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),e("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),t[4]||(t[4]=d('<p>我后来越来越相信：很多团队的“工程气质”，不是写在 code review 里，而是写在发版节奏里——写在你周末到底能不能睡个懒觉里。</p><p>同一个人，换一家公司/部门，做事方式可能会发生很大变化；更准确地说，是系统逼着你变化：业务波动、组织结构、合规要求、团队成熟度，会把“最优解”推来推去。</p><p>这篇就记录一个我亲历过的对照：用友、金山、飞书、以及电商，发版方式各不相同，但各有其合理性与代价。</p><h2 id="_1-四种模式-一张表先把地图画出来" tabindex="-1">1) 四种模式，一张表先把地图画出来 <a class="header-anchor" href="#_1-四种模式-一张表先把地图画出来" aria-label="Permalink to &quot;1) 四种模式，一张表先把地图画出来&quot;">​</a></h2><table tabindex="0"><thead><tr><th>维度</th><th>用友（传统瀑布）</th><th>金山（简化 Git Flow）</th><th>飞书（班车 / Release Train）</th><th>电商（极致敏捷 / 快速回滚）</th></tr></thead><tbody><tr><td>目标函数</td><td>稳定交付、返工最少</td><td>可控发版、节奏稳定</td><td>高并发协作 + 多版本灰度</td><td>抢机会、快速试错</td></tr><tr><td>典型节奏</td><td>大版本、固定发版点</td><td>周期性发版（例如每周一版）</td><td>多车次、多轨道并行</td><td>昨天开发、今天上线</td></tr><tr><td>分支策略</td><td>以需求/版本为中心</td><td>master / release / hotfix</td><td>主干为主 + 版本线/车次</td><td>主干为主 + 快速切换</td></tr><tr><td>测试策略</td><td>多轮评审 + 集中回归</td><td>发版前全量回归</td><td>班车门禁 + 自动化兜底</td><td>线上为真、回滚兜底</td></tr><tr><td>变更处理</td><td>加人或砍需求（通常砍）</td><td>严重问题走 hotfix</td><td>“上车/下车” + Feature Gating</td><td>先上再说，不行就回滚</td></tr><tr><td>适用场景</td><td>流程成熟且需求稳定</td><td>产品节奏较慢但要可控</td><td>超大规模 All-in-one</td><td>强业务驱动、变化剧烈</td></tr><tr><td>体感一句话</td><td>像期末大作业：交卷日写死</td><td>像周更综艺：一周一个档期</td><td>像地铁：站点少才跑得快</td><td>像早市：手快有手慢无</td></tr></tbody></table><p>后面每一节，都不讲“谁更先进”，只讲：它为什么能跑起来、它的成本在哪里、你要靠什么把它跑稳。毕竟发版这件事，很多时候不是工程选择，而是现实选择。</p><h2 id="_2-用友-瀑布式发版——目标明确-但天花板也明确" tabindex="-1">2) 用友：瀑布式发版——目标明确，但天花板也明确 <a class="header-anchor" href="#_2-用友-瀑布式发版——目标明确-但天花板也明确" aria-label="Permalink to &quot;2) 用友：瀑布式发版——目标明确，但天花板也明确&quot;">​</a></h2><p>在用友更像传统软件工程：项目开始前会有大量调研，需求文档相对健全，讨论也会更“正式”。然后大家会围绕一个最终发版点推进。发版点像高考：日期写在黑板上，谁也别想着改，它只会按时来。</p><p>到了那个点，最常见的选项就两个：</p><ul><li>加人</li><li>砍需求</li></ul><p>而现实很残酷：如果已经明显延期，再加人往往只会让进度更慢（经典的“人月神话”）。所以最优雅的方式通常是砍需求：保主线、保核心、保按时。说得再直白点：先把能卖的车造出来，车窗贴膜这种事下个版本再说。</p><p>我印象很深的是，多维报表那条线最后也是这么做的：砍掉一些边角功能，力保多维模型这条主干准时上线。这个模式特别适合“流程稳定”的场景：目标清晰、返工相对少、管理动作可预期。</p><p>代价也很明显：</p><ul><li>需求一旦变快，流程就会显得笨重</li><li>复杂系统的工期依然可能延期，只是延期更“体面”</li><li>一旦踩坑（需求误判、风险漏评），返工会集中爆发</li></ul><h2 id="_3-金山-简化-git-flow——稳定-但分支天然偏重" tabindex="-1">3) 金山：简化 Git Flow——稳定，但分支天然偏重 <a class="header-anchor" href="#_3-金山-简化-git-flow——稳定-但分支天然偏重" aria-label="Permalink to &quot;3) 金山：简化 Git Flow——稳定，但分支天然偏重&quot;">​</a></h2><p>金山的研发更像“从传统往互联网迁移”的中间态：参考了 Git Flow，但做了简化，常见分支大概是 master / release / hotfix（以及各种 feature/bugfix）。节奏大概是“周更”，但不是那种追热点的周更，而是“每周都要把这期节目剪出来”的周更。</p><p>一个典型节奏是：</p><ul><li>非发版周期：feature/bugfix 验证后合入 master，做基本回归</li><li>发版日：从 master 拉出 <code>release-日期</code>，做一次全量回归，然后发布</li><li>若有严重问题：从 hotfix 拉出修复，打补丁</li></ul><p>它的好处是：节奏稳定、职责清晰、发布流水线“每周只跑一个版本”时，组织协作也更容易对齐。对个人来说也有一种朴素的安全感：这周能发就发，发不了就下周，不至于天天被“明天必须上”追着跑。</p><p>它的问题也相对典型：</p><ul><li>分支越多，合并与回归成本越高</li><li>release 分支存在时间越长，越容易出现“修修补补的雪堆”</li><li>对于变化快的业务，发版频率会显得不够敏捷</li></ul><p>如果你把它当作一个“对外开源项目”的标准，基本就是 Git Flow 的思路：release/hotfix 的存在，核心是为了让“发布与开发”解耦、让版本语义清晰。</p>',22)),(i(),o(n,null,{default:a(()=>[s(r,{id:"mermaid-258",class:"mermaid",graph:"flowchart%20LR%0A%20%20M%5Bmaster%5D%20--%3E%7C%E6%8B%89%20release%7C%20R%5Brelease%2F*%5D%0A%20%20R%20--%3E%7C%E5%9B%9E%E5%BD%92%20%26%20%E5%8F%91%E5%B8%83%7C%20M%0A%20%20M%20--%3E%7C%E7%B4%A7%E6%80%A5%E4%BF%AE%E5%A4%8D%7C%20H%5Bhotfix%2F*%5D%0A%20%20H%20--%3E%7C%E5%8F%91%E5%B8%83%E8%A1%A5%E4%B8%81%7C%20M%0A%20%20F%5Bfeature%2F*%5D%20--%3E%7C%E5%90%88%E5%85%A5%7C%20M%0A"})]),fallback:a(()=>[...t[0]||(t[0]=[l(" Loading... ",-1)])]),_:1})),t[5]||(t[5]=e("h2",{id:"_4-飞书-班车制度——把-下车-当成默认能力",tabindex:"-1"},[l("4) 飞书：班车制度——把“下车”当成默认能力 "),e("a",{class:"header-anchor",href:"#_4-飞书-班车制度——把-下车-当成默认能力","aria-label":'Permalink to "4) 飞书：班车制度——把“下车”当成默认能力"'},"​")],-1)),t[6]||(t[6]=e("p",null,"飞书的发布方式里，我最喜欢的类比是“班车”：",-1)),t[7]||(t[7]=e("p",null,"每次发版像一列从始发站开到终点的列车。沿途有站点，站点对应软件开发的阶段（开发、集成、回归、灰度……）。每个站点会有“乘客上车/下车”，这个乘客就是某个功能或补丁。",-1)),t[8]||(t[8]=e("p",null,"这套机制的核心不是“发得快”，而是“并发得稳”。而且它很像一个“默认不信任”的系统：默认会出问题，所以你必须随时能把东西从班车上拎下来。",-1)),t[9]||(t[9]=e("ul",null,[e("li",null,"同一条轨道上可以有不同车次"),e("li",null,"甚至可以同时有不同轨道，灰度好几个版本"),e("li",null,"每趟班车有班车长，有通讯录，出问题能快速定位责任人与快速下车")],-1)),(i(),o(n,null,{default:a(()=>[s(r,{id:"mermaid-288",class:"mermaid",graph:"flowchart%20LR%0A%20%20S%5B%E5%BC%80%E5%8F%91%E7%AB%99%5D%20--%3E%20I%5B%E9%9B%86%E6%88%90%E7%AB%99%5D%0A%20%20I%20--%3E%20T%5B%E5%9B%9E%E5%BD%92%E7%AB%99%5D%0A%20%20T%20--%3E%20G%5B%E7%81%B0%E5%BA%A6%E7%AB%99%5D%0A%20%20G%20--%3E%20P%5B%E5%85%A8%E9%87%8F%E7%AB%99%5D%0A%0A%20%20F1%5B%E5%8A%9F%E8%83%BD%20A%5D%20--%3E%20S%0A%20%20F2%5B%E5%8A%9F%E8%83%BD%20B%5D%20--%3E%20I%0A%20%20F3%5B%E5%8A%9F%E8%83%BD%20C%5D%20--%3E%20T%0A%20%20X%5B%E9%97%AE%E9%A2%98%E5%8A%9F%E8%83%BD%5D%20-.%E4%B8%8B%E8%BD%A6%2F%E5%9B%9E%E6%BB%9A.-%3E%20S%0A"})]),fallback:a(()=>[...t[1]||(t[1]=[l(" Loading... ",-1)])]),_:1})),t[10]||(t[10]=d('<p>为了让“下车”足够敏捷，Feature Gating（功能开关）几乎是强推荐：功能开发完成之后，你不仅要验证“开关打开能用”，还要验证“开关关闭不出事”。这条建议听起来很像废话，但你真在大系统里打过仗，就会知道“关不掉”才是事故的开始。</p><ul><li>可以同时并发很多条线</li><li>线上稳定性更容易守住</li><li>真出了问题，也能把影响控制在灰度范围内</li></ul><p>当然，飞书作为 2B 产品，长期权重更倾向于：稳定 &gt;&gt; 敏捷。班车制度其实就是一种“用流程和门禁守住稳定，同时允许并发”的折中。</p><h2 id="_5-电商-极致敏捷——-库库上线-的另一面是组织成本" tabindex="-1">5) 电商：极致敏捷——“库库上线”的另一面是组织成本 <a class="header-anchor" href="#_5-电商-极致敏捷——-库库上线-的另一面是组织成本" aria-label="Permalink to &quot;5) 电商：极致敏捷——“库库上线”的另一面是组织成本&quot;">​</a></h2><p>到了电商，发版模式可以说把敏捷推到了另一个极端。它不是“快”，它是“快到你来不及认真”。</p><p>原因也不神秘：业务部门承接变现压力，对市场波动非常敏感。很多事情不是线性的：上半年赚钱的玩法，下半年可能就亏；但上半年的利润可能又足够让人“一把翻身”。于是组织会自然偏向“快”，快到你觉得规范和流程像是累赘。</p><p>在一些内部系统里（尤其面向运营同学），会出现这种节奏：</p><ul><li>昨天开发，今天上线</li><li>情况不对，就回滚</li><li>不争论“流程正确”，只争论“今天能不能跑起来”</li></ul><p>伴随而来的代价，是强烈的组织性噪音：你会感觉自己不是在写代码，而是在信息洪水里求生。</p><ul><li>为应对变化而疯狂开会，信息轰炸，从上午到凌晨不稀奇</li><li>跨时区协作把日常节奏打碎</li><li>对有技术追求、想把系统做“可复用/可治理”的同学，会非常痛苦</li></ul><p>我感受到的一个“阶段性改良”是：到了 2025 年，节奏开始稍微收敛，比如限定每周固定两天发版，并加入审批，让系统从“随时可以倒车”变成“至少知道什么时候要上路”。这不一定让事情更快，但会让人更像人。</p><h2 id="_6-抽象成模式-你在优化什么-就会选择什么" tabindex="-1">6) 抽象成模式：你在优化什么，就会选择什么 <a class="header-anchor" href="#_6-抽象成模式-你在优化什么-就会选择什么" aria-label="Permalink to &quot;6) 抽象成模式：你在优化什么，就会选择什么&quot;">​</a></h2><p>我觉得这四种模式的底层差异可以浓缩成一句话：</p><p>你在优化的东西不同：有的优化“确定性”，有的优化“并发吞吐”，有的优化“市场响应”，代价自然不同。</p><p>如果硬要给一个“工程判断”，我会这样落：</p><ul><li><strong>瀑布</strong>更依赖前期确定性（文档/评审/计划），但对变化的容忍度低</li><li>**Git Flow（及其简化版）**用分支表达版本语义，适合可控节奏，但分支越多越重</li><li><strong>班车 / Release Train</strong>强调上车下车、强调门禁与灰度，适合超大规模协作</li><li><strong>极致敏捷</strong>依赖快速回滚与组织协调，适合强业务驱动，但会用会议与心智成本买速度</li></ul><h2 id="_7-如果要做成-开源标准-我会怎么写-git-flow-规则" tabindex="-1">7) 如果要做成“开源标准”：我会怎么写 Git Flow 规则 <a class="header-anchor" href="#_7-如果要做成-开源标准-我会怎么写-git-flow-规则" aria-label="Permalink to &quot;7) 如果要做成“开源标准”：我会怎么写 Git Flow 规则&quot;">​</a></h2><p>假设这是一个对外开源的工程（不是内部口口相传），我更倾向把规则写成“可执行的合同”：</p><ul><li>分支约定：<code>feature/*</code>、<code>release/*</code>、<code>hotfix/*</code>、<code>main/master</code></li><li>合并门禁：PR 必须过 CI（lint / typecheck / unit tests）</li><li>发布语义：语义化版本（SemVer）+ changelog</li><li>回滚策略：可回滚版本产物 + 兼容性说明</li><li>风险隔离：Feature Flag + 默认关闭 + 灰度开关</li></ul><p>写得清楚，才有长期协作；写不清楚，就会变成“大家都懂但谁也说不清”的玄学。然后玄学就会变成会议，会议就会变成加班（严谨的因果链）。</p><h2 id="参考与引用" tabindex="-1">参考与引用 <a class="header-anchor" href="#参考与引用" aria-label="Permalink to &quot;参考与引用&quot;">​</a></h2><ol><li>Vincent Driessen, A successful Git branching model（Git Flow 原文）: <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noreferrer">https://nvie.com/posts/a-successful-git-branching-model/</a></li><li>Fred Brooks, The Mythical Man-Month（人月神话 / Brooks&#39;s Law）: <a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/The_Mythical_Man-Month</a></li><li>Martin Fowler, Feature Toggles（Feature Flag 的工程化视角）: <a href="https://martinfowler.com/articles/feature-toggles.html" target="_blank" rel="noreferrer">https://martinfowler.com/articles/feature-toggles.html</a></li><li>Continuous Delivery（持续交付经典书，对“门禁/流水线/发布策略”很系统）: <a href="https://continuousdelivery.com/" target="_blank" rel="noreferrer">https://continuousdelivery.com/</a></li></ol>',22))])}const F=p(E,[["render",f]]);export{b as __pageData,F as default};
