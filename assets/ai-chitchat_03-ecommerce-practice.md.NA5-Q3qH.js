import{f as r,D as n,c as s,o as p,k as t,a4 as l,H as o,a as i}from"./chunks/framework.BAs4fWuZ.js";const P=JSON.parse('{"title":"电商实战：AIGC 图文生产与 Agent 落地","description":"","frontmatter":{"title":"电商实战：AIGC 图文生产与 Agent 落地","date":"2026-01-21T00:00:00.000Z","categories":"study","tags":["ai-chitchat","diffusion","agent","ecommerce","engineering"]},"headers":[],"relativePath":"ai-chitchat/03-ecommerce-practice.md","filePath":"ai-chitchat/03-ecommerce-practice.md","lastUpdated":1769663832000}'),g={name:"ai-chitchat/03-ecommerce-practice.md"};function m(u,a,d,c,h,_){const e=n("InkMermaidBlock");return p(),s("div",null,[a[0]||(a[0]=t("div",{class:"alert read-stats",role:"note"},[t("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),t("span",{class:"read-stats__text"},[i("本文约 "),t("b",null,"747"),i(" 字，阅读预计耗时 "),t("b",null,"2"),i(" 分钟。")])],-1)),a[1]||(a[1]=t("div",{class:"alert ai-disclosure",role:"note"},[t("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),t("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),a[2]||(a[2]=l('<p>如果说原理部分更多是“知道它为什么看起来聪明”，那落地部分就是“接受它默认不可靠”，然后用工程机制把它变得可控。</p><p>在电商里，难点往往不在“能不能生成”，而在“能不能稳定生成同一种风格、同一种口径、同一种约束”。</p><h2 id="_1-图像篇-从-生成-走向-编辑" tabindex="-1">1. 图像篇：从“生成”走向“编辑” <a class="header-anchor" href="#_1-图像篇-从-生成-走向-编辑" aria-label="Permalink to &quot;1. 图像篇：从“生成”走向“编辑”&quot;">​</a></h2><h3 id="_1-1-mask-inpaint-与-outpaint" tabindex="-1">1.1 Mask, Inpaint 与 Outpaint <a class="header-anchor" href="#_1-1-mask-inpaint-与-outpaint" aria-label="Permalink to &quot;1.1 Mask, Inpaint 与 Outpaint&quot;">​</a></h3><p>在工程上，Mask 不是一个像素图那么简单，它是一个契约：哪些区域允许改，哪些区域必须保持。</p><ul><li><strong>Inpaint（修复）</strong>：在原图上“补”。常见翻车点是边界不一致、语义漂移。</li><li><strong>Outpaint（扩展）</strong>：把画面“扩出去”。常见翻车点是纹理、背景不连贯。</li></ul><h3 id="_1-2-结构化生成-figma-→-json-→-sd" tabindex="-1">1.2 结构化生成：Figma → JSON → SD <a class="header-anchor" href="#_1-2-结构化生成-figma-→-json-→-sd" aria-label="Permalink to &quot;1.2 结构化生成：Figma → JSON → SD&quot;">​</a></h3><p>我做过一类相对工程化的尝试：把“设计稿”拆成结构化模板，让生成模型只负责填坑位。</p><ul><li>输入：Figma 设计稿</li><li>中间表示：模板 JSON（组件、坐标、坑位、约束）</li><li>输出：由 SD 生成图/文素材，再回填到模板里</li></ul><p>这条链路的价值在于：你把“可控性”从 Prompt 转移到“结构与约束”上——工程上更容易治理。</p><h3 id="_1-3-虚拟试衣-工程拼装管线" tabindex="-1">1.3 虚拟试衣：工程拼装管线 <a class="header-anchor" href="#_1-3-虚拟试衣-工程拼装管线" aria-label="Permalink to &quot;1.3 虚拟试衣：工程拼装管线&quot;">​</a></h3><p>虚拟试衣是另一类“生成 + 约束”的问题。一个常见的工程拼装思路是：先把几何/姿态约束做出来，再把生成当作“渲染器”。</p>',12)),o(e,{codeBase64:"Zmxvd2NoYXJ0IFRCCiAgSVvovpPlhaXvvJrkurrnianlm74v6KeG6aKRXSAtLT4gUFvlp7/mgIHkvLDorqE8YnIvPk9wZW5Qb3NlL0RXUG9zZV0KICBJIC0tPiBEW+S6uuS9k+WvhumbhuWvuem9kDxici8+RGVuc2VQb3NlXQogIFAgLS0+IE1b5Yeg5L2VL+mqqOaetue6puadn10KICBEIC0tPiBNCiAgTSAtLT4gUlszRCDku6PnkIYv5bu65qihPGJyLz7nspflh6DkvZXkuI7pga7mjKFdCiAgUiAtLT4gR1vnlJ/miJAv57uG5YyWPGJyLz7mianmlaPmqKHlnotdCiAgRyAtLT4gT1vovpPlh7rvvJror5XooaPmlYjmnpzlm74v6KeG6aKRXQo="}),a[3]||(a[3]=t("h2",{id:"_2-文本篇-agent-的工程落地",tabindex:"-1"},[i("2. 文本篇：Agent 的工程落地 "),t("a",{class:"header-anchor",href:"#_2-文本篇-agent-的工程落地","aria-label":'Permalink to "2. 文本篇：Agent 的工程落地"'},"​")],-1)),a[4]||(a[4]=t("h3",{id:"_2-1-最小闭环-规划-执行-复核",tabindex:"-1"},[i("2.1 最小闭环：规划 / 执行 / 复核 "),t("a",{class:"header-anchor",href:"#_2-1-最小闭环-规划-执行-复核","aria-label":'Permalink to "2.1 最小闭环：规划 / 执行 / 复核"'},"​")],-1)),a[5]||(a[5]=t("p",null,"我更认可的 Agent 形态是“最小闭环”，而不是“自嗨式自动化”：",-1)),o(e,{codeBase64:"c3RhdGVEaWFncmFtLXYyCiAgWypdIC0tPiBQbGFuOiDop4TliJI8YnIvPuaLhuS7u+WKoS/lrprovpPlh7rmoLzlvI8KICBQbGFuIC0tPiBBY3Q6IOaJp+ihjDxici8+5bel5YW36LCD55SoL+ajgOe0oi/nlJ/miJAKICBBY3QgLS0+IFZlcmlmeTog5aSN5qC4PGJyLz7nu5PmnoTmoKHpqowv57qm5p2f5qOA5p+lL+iHquajgAogIFZlcmlmeSAtLT4gRG9uZTog6YCa6L+HCiAgVmVyaWZ5IC0tPiBQbGFuOiDkuI3pgJrov4c8YnIvPuihpeS/oeaBry/mlLnorqHliJIKICBEb25lIC0tPiBbKl0K"}),a[6]||(a[6]=l('<ul><li><strong>规划</strong>：必须把“验收标准”写出来。</li><li><strong>执行</strong>：必须收敛工具数量与失败处理。</li><li><strong>复核</strong>：必须可解释（为什么失败）。</li></ul><h3 id="_2-2-能力分级-l1-l5" tabindex="-1">2.2 能力分级（L1-L5） <a class="header-anchor" href="#_2-2-能力分级-l1-l5" aria-label="Permalink to &quot;2.2 能力分级（L1-L5）&quot;">​</a></h3><p>我在电商场景里更常用的是“能力分级”视角：</p><ul><li><strong>L1 (规则)</strong>：规则驱动的工具调用。</li><li><strong>L2 (推理)</strong>：多路径选择，决策可解释。</li><li><strong>L3 (记忆)</strong>：多轮一致，失败归因。</li><li><strong>L4 (泛化)</strong>：自主学习与策略复用。</li><li><strong>L5 (协作)</strong>：多 Agent 协作。</li></ul><p>级别越高，越难控制。电商场景通常更愿意为 L1-L3 的“可控”付费。</p><h3 id="_2-3-prompt-与-a2ui" tabindex="-1">2.3 Prompt 与 A2UI <a class="header-anchor" href="#_2-3-prompt-与-a2ui" aria-label="Permalink to &quot;2.3 Prompt 与 A2UI&quot;">​</a></h3><p>我写 Prompt 的习惯是把它当作“接口契约”：输入是什么、输出是什么（Schema）、失败怎么处理。</p><p><strong>A2UI</strong> 是一类更偏“把语言变成交付物”的尝试：</p><ul><li>用户自然语言 -&gt; Agent 拆解 -&gt; JSON (Schema 固定) -&gt; XUI 渲染 -&gt; 最终产物。</li><li>关键点：JSON 是工程的地基，让你能做校验、回归、Diff。</li></ul><h2 id="_3-治理与兜底-从个人爽感到团队可控" tabindex="-1">3. 治理与兜底：从个人爽感到团队可控 <a class="header-anchor" href="#_3-治理与兜底-从个人爽感到团队可控" aria-label="Permalink to &quot;3. 治理与兜底：从个人爽感到团队可控&quot;">​</a></h2><p>2025 大概率是 Agent 元年，但难点不会在模型，而在治理。</p><ul><li><strong>成本</strong>：Token、延迟、工具调用次数。</li><li><strong>风险</strong>：合规、版本漂移、依赖锁定。</li><li><strong>兜底</strong>：降级、回滚、人工介入。</li></ul><p>工程人的关键觉悟：<strong>把模型能力当作一个不稳定依赖</strong>。你需要 trace、需要测试、需要对账。</p>',13))])}const A=r(g,[["render",m]]);export{P as __pageData,A as default};
