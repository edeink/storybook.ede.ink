import{f as l,c as i,o as e,a4 as r}from"./chunks/framework.BAs4fWuZ.js";const s=JSON.parse('{"title":"WIP 性能优化（基准测试 + 数据）：大纲","description":"","frontmatter":{"title":"WIP 性能优化（基准测试 + 数据）：大纲"},"headers":[],"relativePath":"performance/__outline.md","filePath":"performance/__outline.md","lastUpdated":1769026429000}'),t={name:"performance/__outline.md"};function o(h,a,n,_,u,d){return e(),i("div",null,[...a[0]||(a[0]=[r('<h2 id="_0-先统一口径" tabindex="-1">0. 先统一口径 <a class="header-anchor" href="#_0-先统一口径" aria-label="Permalink to &quot;0. 先统一口径&quot;">​</a></h2><ul><li>性能是什么：延迟、吞吐、资源、抖动、稳定性</li><li>指标与预算：没有预算就没有治理，没有口径就没有结论</li><li>写作口径：先把“测量”讲明白，再谈“优化”</li></ul><h2 id="_1-基准测试-benchmark" tabindex="-1">1. 基准测试（Benchmark） <a class="header-anchor" href="#_1-基准测试-benchmark" aria-label="Permalink to &quot;1. 基准测试（Benchmark）&quot;">​</a></h2><h3 id="_1-1-基准设计-代表性比-跑得快-更重要" tabindex="-1">1.1 基准设计：代表性比“跑得快”更重要 <a class="header-anchor" href="#_1-1-基准设计-代表性比-跑得快-更重要" aria-label="Permalink to &quot;1.1 基准设计：代表性比“跑得快”更重要&quot;">​</a></h3><ul><li>场景：关键路径、真实负载、数据分布与边界输入</li><li>指标：P50/P90/P99、吞吐、内存峰值、长尾抖动</li><li>口径：固定硬件、固定版本、固定参数与随机种子</li></ul><h3 id="_1-2-噪声与回归判定" tabindex="-1">1.2 噪声与回归判定 <a class="header-anchor" href="#_1-2-噪声与回归判定" aria-label="Permalink to &quot;1.2 噪声与回归判定&quot;">​</a></h3><ul><li>噪声来源：CPU 调频、GC、缓存、网络抖动、后台任务</li><li>判定策略：置信区间、显著性、阈值与回归门禁</li><li>报告格式：对比表 + 结论 + 复现步骤 + 原始数据</li></ul><h2 id="_2-数据与观测-observability" tabindex="-1">2. 数据与观测（Observability） <a class="header-anchor" href="#_2-数据与观测-observability" aria-label="Permalink to &quot;2. 数据与观测（Observability）&quot;">​</a></h2><h3 id="_2-1-指标分层-把问题定位在对的层" tabindex="-1">2.1 指标分层：把问题定位在对的层 <a class="header-anchor" href="#_2-1-指标分层-把问题定位在对的层" aria-label="Permalink to &quot;2.1 指标分层：把问题定位在对的层&quot;">​</a></h3><ul><li>业务指标：转化、留存、漏斗与关键路径</li><li>体验指标：加载、交互、滚动、输入延迟</li><li>系统指标：CPU、内存、网络、错误率、崩溃率</li></ul><h3 id="_2-2-采集策略-观测也有成本" tabindex="-1">2.2 采集策略：观测也有成本 <a class="header-anchor" href="#_2-2-采集策略-观测也有成本" aria-label="Permalink to &quot;2.2 采集策略：观测也有成本&quot;">​</a></h3><ul><li>采样：分层采样、按错误/慢请求加权采样</li><li>聚合：边缘聚合、端上聚合与服务端聚合</li><li>脱敏：PII、token、路径与 payload 的治理</li><li>数据质量：缺失、重复、异常波动与时序对齐</li></ul><h2 id="_3-定位与复盘" tabindex="-1">3. 定位与复盘 <a class="header-anchor" href="#_3-定位与复盘" aria-label="Permalink to &quot;3. 定位与复盘&quot;">​</a></h2><h3 id="_3-1-定位-把-慢-拆成可观测的因果链" tabindex="-1">3.1 定位：把“慢”拆成可观测的因果链 <a class="header-anchor" href="#_3-1-定位-把-慢-拆成可观测的因果链" aria-label="Permalink to &quot;3.1 定位：把“慢”拆成可观测的因果链&quot;">​</a></h3><ul><li>最小复现：固定输入、固定环境、固定路径</li><li>profile：CPU flamegraph、memory heap、GPU 资源</li><li>trace：端到端链路、关键阶段耗时与依赖关系</li><li>对比：变更前后对齐口径，避免“伪提升”</li></ul><h3 id="_3-2-复盘-让优化变成机制" tabindex="-1">3.2 复盘：让优化变成机制 <a class="header-anchor" href="#_3-2-复盘-让优化变成机制" aria-label="Permalink to &quot;3.2 复盘：让优化变成机制&quot;">​</a></h3><ul><li>假设：写清楚因果关系与可证伪条件</li><li>验证：用数据与对比实验验证，而不是靠直觉</li><li>结论：边界条件、收益上限与副作用</li><li>防回归：门禁、报警、回滚与知识沉淀</li></ul><h2 id="_4-治理-把性能当成产品能力" tabindex="-1">4. 治理：把性能当成产品能力 <a class="header-anchor" href="#_4-治理-把性能当成产品能力" aria-label="Permalink to &quot;4. 治理：把性能当成产品能力&quot;">​</a></h2><ul><li>预算：按页面/功能设预算，超预算必须有决策记录</li><li>门禁：关键指标回归阻断合入或阻断发布</li><li>文化：性能事故与功能事故同等对待</li></ul><h2 id="_5-拟发布文章方向" tabindex="-1">5. 拟发布文章方向 <a class="header-anchor" href="#_5-拟发布文章方向" aria-label="Permalink to &quot;5. 拟发布文章方向&quot;">​</a></h2><ul><li>基准测试的工程模板：从场景到报告的完整链路</li><li>指标口径治理：定义、变更、回溯与对账</li><li>性能排障方法：trace + profile + 最小复现</li><li>性能治理体系：预算化、门禁化、规模化</li></ul>',21)])])}const b=l(t,[["render",o]]);export{s as __pageData,b as default};
