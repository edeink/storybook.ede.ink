import{_ as p,C as h,c,o as e,j as i,a2 as r,b as s,a as l,w as t,G as d,a3 as n}from"./chunks/framework.C2eRlmqf.js";const _=JSON.parse('{"title":"开源 Web 富文本横向对比：tiptap / ProseMirror / Slate / Lexical / Quill","description":"","frontmatter":{"title":"开源 Web 富文本横向对比：tiptap / ProseMirror / Slate / Lexical / Quill","date":"2026-01-23T00:00:00.000Z","categories":"study","tags":["web-editor","prosemirror","tiptap","slate","lexical","quill"]},"headers":[],"relativePath":"web-editor/06-open-source-editors-comparison.md","filePath":"web-editor/06-open-source-editors-comparison.md","lastUpdated":1769026429000}'),u={name:"web-editor/06-open-source-editors-comparison.md"};function m(E,a,b,A,P,B){const o=h("Mermaid");return e(),c("div",null,[a[2]||(a[2]=i("div",{class:"alert read-stats",role:"note"},[i("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),i("span",{class:"read-stats__text"},[l("本文约 "),i("b",null,"3511"),l(" 字，阅读预计耗时 "),i("b",null,"9"),l(" 分钟。")])],-1)),a[3]||(a[3]=i("div",{class:"alert ai-disclosure",role:"note"},[i("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),i("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),a[4]||(a[4]=r('<p>编辑器选型这事，最怕拿“demo 手感”当结论：demo 里你编辑 3 行字；线上你要编辑 3 万行，还要协同、批注、粘贴、导入导出、以及各种你根本控制不了的浏览器差异。</p><h2 id="问题-为什么编辑器选型总是吵不完" tabindex="-1">问题：为什么编辑器选型总是吵不完？ <a class="header-anchor" href="#问题-为什么编辑器选型总是吵不完" aria-label="Permalink to &quot;问题：为什么编辑器选型总是吵不完？&quot;">​</a></h2><p>因为大家在比的是不同维度：</p><ul><li>有人关心“体验”：输入法顺不顺，回车/删除会不会跳</li><li>有人关心“可扩展”：能不能定制节点、插件生态怎么样</li><li>有人关心“可控”：文档是不是可回放的事实（model-first）</li><li>有人关心“协同”：CRDT/OT 怎么接、坑多不多</li><li>有人关心“性能”：长文档、复杂装饰器、表格、嵌套列表</li></ul><p>这些维度本身互相拉扯。你最终选的不是“最强编辑器”，而是一套 <strong>复杂度分配方案</strong>：复杂度是框架承受，还是业务承受。</p><h2 id="分析-先把-层次-看清楚-架构堆叠图" tabindex="-1">分析：先把“层次”看清楚（架构堆叠图） <a class="header-anchor" href="#分析-先把-层次-看清楚-架构堆叠图" aria-label="Permalink to &quot;分析：先把“层次”看清楚（架构堆叠图）&quot;">​</a></h2><p>很多人把 tiptap 和 ProseMirror 放在同一层比较，这是不严谨的。</p><ul><li>ProseMirror：底层内核（schema/transaction/view/plugin）</li><li>tiptap：基于 ProseMirror 的封装与扩展体系（更工程化、更易上手）</li></ul><h3 id="堆叠图-源文件-assets-diagrams-editor-oss-stack-mmd" tabindex="-1">堆叠图（源文件：<code>../assets/diagrams/editor-oss-stack.mmd</code>） <a class="header-anchor" href="#堆叠图-源文件-assets-diagrams-editor-oss-stack-mmd" aria-label="Permalink to &quot;堆叠图（源文件：`../assets/diagrams/editor-oss-stack.mmd`）&quot;">​</a></h3>',9)),(e(),s(n,null,{default:t(()=>[d(o,{id:"mermaid-62",class:"mermaid",graph:"flowchart%20TB%0A%20%20subgraph%20TipTap%5B%22tiptap%22%5D%0A%20%20%20%20T1%5BExtension%20System%5D%0A%20%20%20%20T2%5BCommands%2FReact%2FVue%20bindings%5D%0A%20%20end%0A%0A%20%20subgraph%20PM%5B%22ProseMirror%22%5D%0A%20%20%20%20P1%5BSchema%2FNode%2FMark%5D%0A%20%20%20%20P2%5BTransaction%2FStep%2FMapping%5D%0A%20%20%20%20P3%5BState%2FPlugin%5D%0A%20%20%20%20P4%5BView%2FDOM%20integration%5D%0A%20%20end%0A%0A%20%20subgraph%20Others%5B%22Other%20ecosystems%22%5D%0A%20%20%20%20S%5BSlate%3Cbr%2F%3E(React-first)%5D%0A%20%20%20%20L%5BLexical%3Cbr%2F%3E(Perf%2Fengineering)%5D%0A%20%20%20%20Q%5BQuill%3Cbr%2F%3E(Delta-based)%5D%0A%20%20end%0A%0A%20%20TipTap%20--%3E%20PM%0A"})]),fallback:t(()=>[...a[0]||(a[0]=[l(" Loading... ",-1)])]),_:1})),a[5]||(a[5]=r('<h2 id="横向对比-工程维度-主流方案" tabindex="-1">横向对比：工程维度（主流方案） <a class="header-anchor" href="#横向对比-工程维度-主流方案" aria-label="Permalink to &quot;横向对比：工程维度（主流方案）&quot;">​</a></h2><table tabindex="0"><thead><tr><th>方案</th><th>核心抽象</th><th>文档事实</th><th>扩展方式</th><th>生态</th><th>适合什么团队</th></tr></thead><tbody><tr><td>ProseMirror</td><td>Schema + Transaction + Step</td><td>model-first</td><td>Plugin/NodeView/Mark</td><td>强</td><td>愿意投入底层能力的团队</td></tr><tr><td>tiptap</td><td>PM + Extension</td><td>model-first</td><td>Extension + Command</td><td>强（PM 生态）</td><td>想快速落地且可扩展的团队</td></tr><tr><td>Slate</td><td>React-first Tree</td><td>偏自由</td><td>transforms + normalization</td><td>中</td><td>强业务定制、可接受自己兜底</td></tr><tr><td>Lexical</td><td>EditorState + Node</td><td>model-first（偏工程）</td><td>plugins/nodes</td><td>中</td><td>性能敏感、工程化强的团队</td></tr><tr><td>Quill</td><td>Delta（ops）</td><td>ops-first</td><td>modules/blots</td><td>中</td><td>常规富文本、定制深度适中</td></tr></tbody></table><h3 id="一个不讨喜但实用的结论" tabindex="-1">一个不讨喜但实用的结论 <a class="header-anchor" href="#一个不讨喜但实用的结论" aria-label="Permalink to &quot;一个不讨喜但实用的结论&quot;">​</a></h3><ul><li>你要“长期可控”与“协同可回放”，更接近 ProseMirror 路线（含 tiptap）</li><li>你要“自由度”与“React 习惯”，Slate 会让你更舒服，但需要你自己把坑填平</li><li>你要“工程化 + 性能”，Lexical 值得认真看，但生态与一些复杂富文本能力仍在演进</li><li>Quill 很成熟，但深度定制时你会触到一些结构表达的天花板</li></ul><h2 id="解决方案-用-轮点-来做选型-而不是用-功能列表" tabindex="-1">解决方案：用“轮点”来做选型，而不是用“功能列表” <a class="header-anchor" href="#解决方案-用-轮点-来做选型-而不是用-功能列表" aria-label="Permalink to &quot;解决方案：用“轮点”来做选型，而不是用“功能列表”&quot;">​</a></h2><p>这里借用之前的“轮点”：</p><ul><li>轮点 0：只要能编辑（contenteditable / 简单富文本）</li><li>轮点 1：需要可控模型（model-first：schema/transaction）</li><li>轮点 2：需要协同与可回放（op log + snapshot）</li><li>轮点 3：需要治理与可运维（插件隔离、性能预算、观测）</li></ul><p>选型思路：</p><ul><li>如果你停留在轮点 0：不要上来就“最强框架”，你可能只是需要一个成熟的常规富文本</li><li>如果你要轮点 1-2：不要怕“底层成本”，怕的是线上不可控</li></ul><h2 id="工程实践-用-三问法-比较编辑器-而不是用-代码片段" tabindex="-1">工程实践：用“三问法”比较编辑器，而不是用“代码片段” <a class="header-anchor" href="#工程实践-用-三问法-比较编辑器-而不是用-代码片段" aria-label="Permalink to &quot;工程实践：用“三问法”比较编辑器，而不是用“代码片段”&quot;">​</a></h2><p>很多选型讨论的误区是：看一段示例代码、跑一个 demo，就下结论。其实你要问的是三件事：</p><ol><li>真相在哪：文档的事实表达是 DOM、JSON、还是模型层事务？</li><li>变化怎么发生：输入如何变成可回放的 steps/ops？是否可合并、可压缩、可审计？</li><li>扩展点在哪里：插件能影响输入/状态/渲染的哪一段？边界与治理能力如何？</li></ol><p>把这三问当成“面试题”，不同框架的性格会非常明显。</p><h3 id="_1-prosemirror-像-数据库内核-强约束换可控性" tabindex="-1">1) ProseMirror：像“数据库内核”，强约束换可控性 <a class="header-anchor" href="#_1-prosemirror-像-数据库内核-强约束换可控性" aria-label="Permalink to &quot;1) ProseMirror：像“数据库内核”，强约束换可控性&quot;">​</a></h3><ul><li>真相：Schema + Node Tree + Transaction/Step（model-first）</li><li>变化：一切变化都被表达成 steps，可回放、可映射（mapping）</li><li>扩展：Plugin/NodeView/Decoration 等插槽丰富，但你必须尊重模型层规则</li></ul><p>比喻：PM 像一个数据库内核。你不会直接去改磁盘页（DOM），你会走事务（transaction），数据库帮你保证一致性（schema+normalize 的效果）。</p><h3 id="_2-tiptap-像-工程化-sdk-把-pm-的门槛砍掉一截" tabindex="-1">2) tiptap：像“工程化 SDK”，把 PM 的门槛砍掉一截 <a class="header-anchor" href="#_2-tiptap-像-工程化-sdk-把-pm-的门槛砍掉一截" aria-label="Permalink to &quot;2) tiptap：像“工程化 SDK”，把 PM 的门槛砍掉一截&quot;">​</a></h3><ul><li>真相：仍然是 PM 模型</li><li>变化：在 PM 的事务体系里运转</li><li>扩展：Extension 让“命令、快捷键、节点、mark”这类常用能力更好组装</li></ul><p>比喻：tiptap 像基于数据库的 ORM/SDK：不改变底层事实，但让你更快写业务，代价是你有时会被封装的抽象带着走。</p><h3 id="_3-slate-像-画布-自由度高-但一致性要自己扛" tabindex="-1">3) Slate：像“画布”，自由度高，但一致性要自己扛 <a class="header-anchor" href="#_3-slate-像-画布-自由度高-但一致性要自己扛" aria-label="Permalink to &quot;3) Slate：像“画布”，自由度高，但一致性要自己扛&quot;">​</a></h3><ul><li>真相：React-first 的树结构（更像“你自己定义的模型”）</li><li>变化：transforms + normalization（你需要自己写很多约束与修复逻辑）</li><li>扩展：几乎全靠自定义；强业务团队很舒服，但也更容易长出不一致</li></ul><p>比喻：Slate 像一张画布：你想画什么都行，但“画完后要不要自动对齐网格、线条能不能交叉”都得你自己决定。自由度就是成本。</p><h3 id="_4-lexical-像-工程化引擎-目标是性能与可维护" tabindex="-1">4) Lexical：像“工程化引擎”，目标是性能与可维护 <a class="header-anchor" href="#_4-lexical-像-工程化引擎-目标是性能与可维护" aria-label="Permalink to &quot;4) Lexical：像“工程化引擎”，目标是性能与可维护&quot;">​</a></h3><ul><li>真相：EditorState + Node（偏工程化的 model-first）</li><li>变化：强调 update 事务与监听机制，减少无谓重渲染</li><li>扩展：插件与节点体系清晰，但生态仍在快速演进，复杂富文本场景要做更多验证</li></ul><p>比喻：Lexical 更像“为高性能场景设计的引擎”，你会得到更好的基础设施，但也需要接受生态成熟度的波动。</p><h3 id="_5-quill-像-成熟组件库-常规富文本体验稳定" tabindex="-1">5) Quill：像“成熟组件库”，常规富文本体验稳定 <a class="header-anchor" href="#_5-quill-像-成熟组件库-常规富文本体验稳定" aria-label="Permalink to &quot;5) Quill：像“成熟组件库”，常规富文本体验稳定&quot;">​</a></h3><ul><li>真相：Delta（ops-first），表达常见富文本足够</li><li>变化：对常见编辑交互做了大量工程打磨</li><li>扩展：Modules/Blots，可定制但结构表达能力会遇到边界</li></ul><p>比喻：Quill 像一辆成熟家用车：日常开很舒服，但你想把它改成越野车，会发现底盘不是为你准备的。</p><h3 id="一张-选型决策-流程图-把团队现状也纳入模型" tabindex="-1">一张“选型决策”流程图：把团队现状也纳入模型 <a class="header-anchor" href="#一张-选型决策-流程图-把团队现状也纳入模型" aria-label="Permalink to &quot;一张“选型决策”流程图：把团队现状也纳入模型&quot;">​</a></h3>',29)),(e(),s(n,null,{default:t(()=>[d(o,{id:"mermaid-404",class:"mermaid",graph:"flowchart%20TB%0A%20%20A%5B%E9%9C%80%E6%B1%82%E7%94%BB%E5%83%8F%5D%20--%3E%20B%7B%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%3Cbr%2F%3E%E5%8F%AF%E5%9B%9E%E6%94%BE%2F%E5%BC%BA%E4%B8%80%E8%87%B4%E6%A8%A1%E5%9E%8B%3F%7D%0A%20%20B%20--%3E%7C%E6%98%AF%7C%20PM%5BProseMirror%2Ftiptap%20%E8%B7%AF%E7%BA%BF%5D%0A%20%20B%20--%3E%7C%E5%90%A6%7C%20C%7B%E6%98%AF%E5%90%A6%E6%9E%81%E5%BA%A6%E4%BE%9D%E8%B5%96%20React%3Cbr%2F%3E%E5%B9%B6%E6%8E%A5%E5%8F%97%E8%87%AA%E5%85%9C%E5%BA%95%3F%7D%0A%20%20C%20--%3E%7C%E6%98%AF%7C%20SL%5BSlate%20%E8%B7%AF%E7%BA%BF%5D%0A%20%20C%20--%3E%7C%E5%90%A6%7C%20D%7B%E6%98%AF%E5%90%A6%E6%80%A7%E8%83%BD%E6%95%8F%E6%84%9F%3Cbr%2F%3E%E4%B8%94%E8%83%BD%E6%8E%A5%E5%8F%97%E7%94%9F%E6%80%81%E6%BC%94%E8%BF%9B%3F%7D%0A%20%20D%20--%3E%7C%E6%98%AF%7C%20LX%5BLexical%20%E8%B7%AF%E7%BA%BF%5D%0A%20%20D%20--%3E%7C%E5%90%A6%7C%20QL%5BQuill%2F%E6%88%90%E7%86%9F%E5%AF%8C%E6%96%87%E6%9C%AC%E8%B7%AF%E7%BA%BF%5D%0A"})]),fallback:t(()=>[...a[1]||(a[1]=[l(" Loading... ",-1)])]),_:1})),a[6]||(a[6]=r('<p>四舍五入：框架选型不是“买哪把更贵的锤子”，而是“你准备把复杂度放在框架、团队能力、还是线上运维上”。</p><h2 id="选型落地-一个靠谱的-poc-应该测什么-别只测-能不能加粗" tabindex="-1">选型落地：一个靠谱的 PoC 应该测什么（别只测“能不能加粗”） <a class="header-anchor" href="#选型落地-一个靠谱的-poc-应该测什么-别只测-能不能加粗" aria-label="Permalink to &quot;选型落地：一个靠谱的 PoC 应该测什么（别只测“能不能加粗”）&quot;">​</a></h2><p>选型最容易出现的“幻觉”是：你拿一个 demo 写了 3 天，觉得一切顺滑；上线后用户写 3 万字、粘贴 Office、开协同、插 30 张图，你才发现你测的根本不是同一个问题。</p><p>建议 PoC 至少覆盖四类“会要命”的场景，每类都要有可复现脚本：</p><ol><li>输入法与移动端</li></ol><ul><li>中文 IME：composition 下连续输入、候选上屏、撤销重做</li><li>移动端：系统选词、长按拖拽光标、自动纠错</li><li>判定标准：光标不乱跳、选区不闪烁、撤销语义符合直觉</li></ul><ol start="2"><li>粘贴与导入</li></ol><ul><li>Office/网页/飞书复制：带样式、带列表、带表格、带图片</li><li>判定标准：结构能被 normalize 到合法 schema，且结果可预期（失败要可解释）</li></ul><ol start="3"><li>长文档性能</li></ol><ul><li>3 万字 + 大量标注/高亮 + 表格</li><li>判定标准：输入延迟、滚动流畅度、内存增长曲线（越用越慢是大忌）</li></ul><ol start="4"><li>协同与回放</li></ol><ul><li>两端并发编辑 + 断网重连 + 压缩/快照</li><li>判定标准：对账一致、可回放定位、事故可修复</li></ul><p>比喻一下：这就像买车不能只试“能不能启动”，要试爬坡、油耗、刹车距离、冬天冷启动。编辑器选型也一样。</p><h2 id="迁移成本-你真正要付的钱-不在代码里" tabindex="-1">迁移成本：你真正要付的钱，不在代码里 <a class="header-anchor" href="#迁移成本-你真正要付的钱-不在代码里" aria-label="Permalink to &quot;迁移成本：你真正要付的钱，不在代码里&quot;">​</a></h2><p>很多团队会低估迁移成本，因为它不完全是“写多少代码”，而是“改多少组织与流程”：</p><ul><li>schema 迁移：旧文档如何映射到新模型？历史数据怎么导入？</li><li>插件迁移：现有业务扩展点如何落到新框架？有没有等价能力？</li><li>数据治理：脏数据以前靠浏览器容忍，现在要不要补 normalize？</li><li>排障体系：有没有 oplog？有没有回放工具？有没有可观测指标？</li></ul><p>如果你打算做一个长期演进的编辑器，建议把“可运维”当成选型的一部分，而不是上线后的补丁。</p><h2 id="性能与异常处理-选型里最容易被忽略的部分" tabindex="-1">性能与异常处理：选型里最容易被忽略的部分 <a class="header-anchor" href="#性能与异常处理-选型里最容易被忽略的部分" aria-label="Permalink to &quot;性能与异常处理：选型里最容易被忽略的部分&quot;">​</a></h2><h3 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h3><ul><li>长文档：定位（position mapping）与渲染增量能力很关键</li><li>装饰器/高亮：区间索引（interval tree）与缓存策略决定上限</li><li>表格/嵌套结构：操作语义复杂，框架的“结构表达能力”决定你写多少 hack</li></ul><h3 id="异常" tabindex="-1">异常 <a class="header-anchor" href="#异常" aria-label="Permalink to &quot;异常&quot;">​</a></h3><ul><li>输入法：框架是否把 IME 作为第一公民（这点对体验很致命）</li><li>粘贴：HTML sanitize 与结构归一化（normalization）能力</li><li>插件：异常隔离与可观测性（不然就等着“幽灵 bug”）</li></ul><h2 id="建议-把选型结论写成-决策记录-而不是写成-口头共识" tabindex="-1">建议：把选型结论写成“决策记录”，而不是写成“口头共识” <a class="header-anchor" href="#建议-把选型结论写成-决策记录-而不是写成-口头共识" aria-label="Permalink to &quot;建议：把选型结论写成“决策记录”，而不是写成“口头共识”&quot;">​</a></h2><p>选型争论之所以会反复发生，是因为很多结论停留在“感觉”。更稳的做法是写一份轻量的决策记录，核心只回答三件事：</p><ul><li>你们的目标轮点是什么（0/1/2/3），以及为什么不是更高/更低</li><li>你们最看重的 3 个指标是什么（例如 IME 稳定性、长文档输入延迟、协同可回放）</li><li>你们愿意承担的 3 个成本是什么（例如底层学习曲线、插件迁移、线上运维体系）</li></ul><p>写清楚这些之后，很多“宗教战争”会自然消失：因为大家讨论的不是框架喜好，而是复杂度分配。框架只是把复杂度放在不同位置，你的团队能力与产品阶段才是最终答案。</p><h2 id="一个更-残酷但现实-的建议-先选一条你能坚持-2-年的路线" tabindex="-1">一个更“残酷但现实”的建议：先选一条你能坚持 2 年的路线 <a class="header-anchor" href="#一个更-残酷但现实-的建议-先选一条你能坚持-2-年的路线" aria-label="Permalink to &quot;一个更“残酷但现实”的建议：先选一条你能坚持 2 年的路线&quot;">​</a></h2><p>编辑器选型最怕的是“第一版为了快，第二版推倒重来”。推倒重来的代价往往不是重写编辑器本身，而是重写生态：文档格式、插件、协同协议、导入导出、以及围绕编辑器建立起来的运营与内容工具链。</p><p>因此我更建议你在选型时多问一问“未来两年”：</p><ul><li>你们会不会走向协同？会不会需要可回放排障？</li><li>你们的文档模型会不会变复杂（表格、公式、嵌套结构、附件）？</li><li>你们会不会走向插件生态（业务扩展点越来越多）？</li></ul><p>如果答案大概率是“会”，那你需要的就不是一个“能用的编辑器”，而是一套能承受演进的底座。它未必一开始最省事，但它会让你在后期少踩很多“结构表达不够用、只能靠 hack” 的坑。</p><p>反过来，如果你的产品形态很明确，需求长期稳定，团队也不准备投入底层能力，那选择成熟、稳定、接入成本低的方案反而更划算：因为你付出的不是“编辑器研发成本”，而是“业务交付速度”的机会成本。</p><h2 id="生态现实-你最终会花时间在-边界行为-而不是-基础-api" tabindex="-1">生态现实：你最终会花时间在“边界行为”而不是“基础 API” <a class="header-anchor" href="#生态现实-你最终会花时间在-边界行为-而不是-基础-api" aria-label="Permalink to &quot;生态现实：你最终会花时间在“边界行为”而不是“基础 API”&quot;">​</a></h2><p>很多框架对比文章会用 API 演示来展示能力：加粗、插入节点、快捷键。真实工程里，你更常花时间在边界行为上：</p><ul><li>输入法：组合输入、候选上屏、撤销重做在 composition 下的语义</li><li>粘贴：Office/网页复制带来的半结构化 HTML 与奇怪样式</li><li>表格：结构操作与选区映射的组合爆炸</li><li>协同：重连补洞、对账、快照、以及偶现分歧的排障</li></ul><p>这些问题的共同点是：它们不是“有没有某个 API”能解决的，而是框架的核心抽象与工程设施能不能承受。也因此同一套功能列表，在不同框架里意味着完全不同的后续成本：有的框架把成本藏在内核里，有的框架把成本推到业务里。</p><p>四舍五入：选型真正要比的不是“能不能做到”，而是“做到以后能不能稳定运维”。</p><h2 id="验证方式-用自动化脚本把-poc-变成可复用的回归套件" tabindex="-1">验证方式：用自动化脚本把 PoC 变成可复用的回归套件 <a class="header-anchor" href="#验证方式-用自动化脚本把-poc-变成可复用的回归套件" aria-label="Permalink to &quot;验证方式：用自动化脚本把 PoC 变成可复用的回归套件&quot;">​</a></h2><p>选型最大的风险之一是：你做了一次 PoC，得出一个结论，然后半年后需求变了、插件变多了、协同上线了，这个结论失效但没人意识到。更稳的做法是把 PoC 过程产出的关键场景做成自动化脚本，让它能在未来持续跑。</p><p>这套脚本不一定需要很重的端到端框架，关键是可重复：</p><ul><li>固定输入序列：模拟 keydown/composition/paste 的序列（尤其是 IME）</li><li>固定文档样本：长文档、表格、混排、带图片与批注的样本</li><li>固定观测指标：输入延迟、内存增长、撤销语义、协同对账一致性</li></ul><p>当你把这些东西固化下来，选型就不再是一次性的“拍板”，而是一条可持续验证的工程路线：你可以在插件扩展、核心升级、协同协议变更时快速回归，确保你没有在不知不觉中跨过某个“轮点”却还沿用旧架构。</p><p>另一个经常被忽略的维度是“文档格式与迁移”。很多团队会把选型等价成“选一个编辑器组件”，但编辑器真正沉淀的是内容资产：你存的是 HTML、JSON、还是 ops？将来 schema 演进时，你有没有一条可重复的迁移管线？如果没有，选型就会在某个版本升级时变成一次“内容灾难”。</p><p>因此哪怕你暂时不做协同，也建议在 PoC 里做一个最小迁移演练：设计一处 schema 变更（例如列表节点多一个属性），把旧文档批量迁移到新文档，再验证“渲染一致、编辑一致、撤销一致”。它能提前暴露很多框架差异：有的框架迁移成本很低，有的框架会把你拖进大量边界修复与兼容代码。</p><h2 id="参考与引用" tabindex="-1">参考与引用 <a class="header-anchor" href="#参考与引用" aria-label="Permalink to &quot;参考与引用&quot;">​</a></h2><ol><li>ProseMirror Guide：<a href="https://prosemirror.net/docs/guide/" target="_blank" rel="noreferrer">https://prosemirror.net/docs/guide/</a> （Bib: <code>prosemirror_guide</code>）</li><li>tiptap Documentation：<a href="https://tiptap.dev/" target="_blank" rel="noreferrer">https://tiptap.dev/</a> （Bib: <code>tiptap_docs</code>）</li><li>Slate Documentation：<a href="https://docs.slatejs.org/" target="_blank" rel="noreferrer">https://docs.slatejs.org/</a> （Bib: <code>slate_docs</code>）</li><li>Lexical Documentation：<a href="https://lexical.dev/docs" target="_blank" rel="noreferrer">https://lexical.dev/docs</a> （Bib: <code>lexical_docs</code>）</li><li>Quill Documentation：<a href="https://quilljs.com/docs/quickstart/" target="_blank" rel="noreferrer">https://quilljs.com/docs/quickstart/</a> （Bib: <code>quill_docs</code>）</li></ol>',46))])}const q=p(u,[["render",m]]);export{_ as __pageData,q as default};
