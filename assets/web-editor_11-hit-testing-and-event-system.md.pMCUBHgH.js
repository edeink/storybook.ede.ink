import{f as n,D as o,c as s,o as p,k as e,a5 as i,H as r,a as l}from"./chunks/framework.BsEAYNxL.js";const y=JSON.parse('{"title":"点击测试（Hit Testing）与事件系统：从坐标到交互闭环","description":"","frontmatter":{"title":"点击测试（Hit Testing）与事件系统：从坐标到交互闭环","date":"2026-01-28T00:00:00.000Z","categories":"study","tags":["web-editor","hit-testing","event-system","pointer-events","performance"]},"headers":[],"relativePath":"web-editor/11-hit-testing-and-event-system.md","filePath":"web-editor/11-hit-testing-and-event-system.md","lastUpdated":1769193553000}'),h={name:"web-editor/11-hit-testing-and-event-system.md"};function c(d,a,u,g,m,b){const t=o("InkMermaidBlock");return p(),s("div",null,[a[0]||(a[0]=e("div",{class:"alert read-stats",role:"note"},[e("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),e("span",{class:"read-stats__text"},[l("本文约 "),e("b",null,"4285"),l(" 字，阅读预计耗时 "),e("b",null,"11"),l(" 分钟。")])],-1)),a[1]||(a[1]=e("div",{class:"alert ai-disclosure",role:"note"},[e("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),e("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),a[2]||(a[2]=i('<p>点击测试是编辑器里最“朴素但昂贵”的能力：把 (x, y) 翻译成文档事实。</p><h2 id="点击测试的实现方式-从坐标到交互闭环" tabindex="-1">点击测试的实现方式（从坐标到交互闭环） <a class="header-anchor" href="#点击测试的实现方式-从坐标到交互闭环" aria-label="Permalink to &quot;点击测试的实现方式（从坐标到交互闭环）&quot;">​</a></h2><p>一句话：<strong>把屏幕坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 映射成文档位置（node + offset）</strong>。</p><p>屏幕坐标代表“用户看到的世界”（视觉坐标系），文档位置代表“系统认的事实”（数据坐标系）。所以点击测试的本质是：在界面与数据之间打通一条通道，让你能把一次输入（点击/拖拽/悬停）稳定地落到可回放、可校验的文档模型上。</p><p>换个更底层的说法：点击测试也是一种碰撞检测（collision detection）——用一个点（或一条线段、一个矩形）去命中一组几何形状（文本行盒、字形边界、节点包围盒、装饰器区域），找出“到底撞到了谁”。</p><p>编辑器里的常见点击测试（hit test）目标：</p><ul><li>插入点定位（caret）：点击某行某字，光标要落在“最接近”的字符边界</li><li>节点命中：点击图片/表格/附件，选中对应节点</li><li>交互对象：点击批注气泡、拖拽锚点、调整手柄</li></ul><h3 id="动机-为什么需要自己做点击测试" tabindex="-1">动机：为什么需要自己做点击测试？ <a class="header-anchor" href="#动机-为什么需要自己做点击测试" aria-label="Permalink to &quot;动机：为什么需要自己做点击测试？&quot;">​</a></h3><p>你当然可以把 hit testing 交给 DOM（例如 <code>document.caretRangeFromPoint</code> / <code>elementFromPoint</code>）。在“DOM 渲染 + 少量装饰”的场景里，这条路确实省事。</p><p>但当你走到下面这些场景，自己做点击测试就变成必选项，而不是“优化项”：</p><ul><li>自绘渲染：Canvas/WebGL/WebGPU 渲染时，没有浏览器的 DOM 命中可用</li><li>多层装饰：overlay/浮层/批注/协同光标叠加时，DOM 命中与真实交互对象不再一致</li><li>虚拟化：只渲染视口后，屏幕上的对象集合不等价于文档中的对象集合</li><li>一致性：你需要可解释、可治理、可回放的命中结果，而不是“浏览器这次返回了啥”</li></ul><p>四舍五入：你不是在做一个“点击回调”，你是在为后续的选区、事件系统、插件系统建立“输入 → 数据”的第一跳。</p><h3 id="从易到难-三种落地路径" tabindex="-1">从易到难：三种落地路径 <a class="header-anchor" href="#从易到难-三种落地路径" aria-label="Permalink to &quot;从易到难：三种落地路径&quot;">​</a></h3><h4 id="两层抽象-几何层与索引层" tabindex="-1">两层抽象：几何层与索引层 <a class="header-anchor" href="#两层抽象-几何层与索引层" aria-label="Permalink to &quot;两层抽象：几何层与索引层&quot;">​</a></h4><ol><li>几何层：你必须有稳定的几何数据（lines/runs/rects）</li><li>索引层：你必须把几何数据组织成可查询的结构（否则就是 O(n) 扫描）</li></ol><h4 id="点击测试流程图" tabindex="-1">点击测试流程图 <a class="header-anchor" href="#点击测试流程图" aria-label="Permalink to &quot;点击测试流程图&quot;">​</a></h4>',16)),r(t,{codeBase64:"Zmxvd2NoYXJ0IExSCiAgUFvmjIfpkojlnZDmoIcgKHgseSldIC0tPiBMW+WumuS9jeihjDxici8+KOaMiSB5IOS6jOWIhildCiAgTCAtLT4gUlvlrprkvY3mloflrZfmrrUgKHJ1bik8YnIvPijljLrpl7TntKLlvJUpXQogIFIgLS0+IENb5a6a5L2N5a2X56ymL+ewhyAoY2x1c3Rlcik8YnIvPijmjIkgYWR2YW5jZSDkuozliIYpXQogIEMgLS0+IE9b5paH5qGj5L2N572uPGJyLz4obm9kZSwgb2Zmc2V0KV0KICBPIC0tPiBBW+WKqOS9nDxici8+5YWJ5qCHL+mAieWMui/oioLngrldCg=="}),a[3]||(a[3]=i('<h4 id="方案-1-按行二分-行内二分-文本插入点的基线" tabindex="-1">方案 1：按行二分 + 行内二分（文本插入点的基线） <a class="header-anchor" href="#方案-1-按行二分-行内二分-文本插入点的基线" aria-label="Permalink to &quot;方案 1：按行二分 + 行内二分（文本插入点的基线）&quot;">​</a></h4><p>假设你已经有排版结果：</p><ul><li>每行一个 <code>yTop..yBottom</code></li><li>每行一个 glyph run（字符 advance 累加数组）</li></ul><p>点击测试就可以做两次二分：</p><ol><li>按 y 找行（log n）</li><li>在行内按 x 找字符（log m）</li></ol><h4 id="算法示意-二分定位-行-与-字符" tabindex="-1">算法示意：二分定位“行”与“字符” <a class="header-anchor" href="#算法示意-二分定位-行-与-字符" aria-label="Permalink to &quot;算法示意：二分定位“行”与“字符”&quot;">​</a></h4><p>你可以把 hit testing 想成“地址反查”：</p><ul><li>y 像楼层：先确定你在哪一层（哪一行）</li><li>x 像门牌号：再确定你在这一层的哪一户（哪一个字符边界）</li></ul><h5 id="_1-按-y-定位行-binary-search-by-y" tabindex="-1">1) 按 y 定位行（binary search by y） <a class="header-anchor" href="#_1-按-y-定位行-binary-search-by-y" aria-label="Permalink to &quot;1) 按 y 定位行（binary search by y）&quot;">​</a></h5><p>已知每一行有垂直范围 [topᵢ, bottomᵢ]，并且这些范围按 y 单调递增。</p><p>目标：找到最小的 i，使得 y ≤ bottomᵢ 且 y ≥ topᵢ（或落在最接近的行）。</p><p>边界条件要写清楚：</p><ul><li>y 在第一行之上：落到 0</li><li>y 在最后一行之下：落到 last</li><li>y 落在两行间隙：通常选择更近的一行（或按产品规则偏上/偏下）</li></ul><h5 id="_2-行内按-x-定位字符-binary-search-by-prefix-advances" tabindex="-1">2) 行内按 x 定位字符（binary search by prefix advances） <a class="header-anchor" href="#_2-行内按-x-定位字符-binary-search-by-prefix-advances" aria-label="Permalink to &quot;2) 行内按 x 定位字符（binary search by prefix advances）&quot;">​</a></h5><p>行内我们不直接二分“字符宽度”，而是二分“累加宽度”（prefix sum）：</p><ul><li>advances[i] = 第 i 个字符（或 glyph cluster）右边界的 x（累加）</li></ul><p>目标：找到最小 i，使得 advances[i] ≥ x。</p><p>同样有两个经典边界：</p><ul><li>x ≤ 0：落到行首</li><li>x ≥ advances[last]：落到行尾（注意这不是最后一个字符的位置，而是“末尾插入点”）</li></ul><h4 id="方案-2-对象命中-图片-批注-手柄-与空间索引" tabindex="-1">方案 2：对象命中（图片/批注/手柄）与空间索引 <a class="header-anchor" href="#方案-2-对象命中-图片-批注-手柄-与空间索引" aria-label="Permalink to &quot;方案 2：对象命中（图片/批注/手柄）与空间索引&quot;">​</a></h4><p>字符 hit test 是一条线（x 轴），但节点命中是 2D（rects）。</p><p>常见做法：</p><ul><li>行内对象：用区间树/有序数组按 x 做查询</li><li>2D 对象：用 R-Tree、网格 hash、或分层索引</li></ul><h4 id="算法示意-行内对象命中-区间查询" tabindex="-1">算法示意：行内对象命中（区间查询） <a class="header-anchor" href="#算法示意-行内对象命中-区间查询" aria-label="Permalink to &quot;算法示意：行内对象命中（区间查询）&quot;">​</a></h4><p>把一行内的对象（批注下划线、装饰器、手柄）看成区间集合：</p><ul><li>spans = {[x0, x1], …}，并按 x0 排序</li></ul><p>一种非常实用的工程折中是“两段式”：</p><ol><li>二分找到最后一个满足 x0 ≤ x 的区间位置（候选集合的右边界）</li><li>从这个位置向左扫描，直到遇到 x1 &lt; x（说明再往左也不可能命中）</li></ol><p>它的好处是实现简单、常数项小，适合“每行对象数量不太夸张”的场景；当 spans 数量很大或更新频繁，就应该升级成区间树/网格索引（前一篇数据结构里已经解释了区间树的剪枝直觉）。</p><h4 id="方案-3-场景树命中-scene-graph-层级-变换-z-order" tabindex="-1">方案 3：场景树命中（scene graph）：层级 + 变换 + z-order <a class="header-anchor" href="#方案-3-场景树命中-scene-graph-层级-变换-z-order" aria-label="Permalink to &quot;方案 3：场景树命中（scene graph）：层级 + 变换 + z-order&quot;">​</a></h4><p>当你渲染不再是 DOM，而是 Canvas/WebGL，你需要一个“交互对象模型”：</p><ul><li>场景树（scene graph）：对象的层级、变换、可见性</li><li>命中规则：矩形、路径、像素级</li><li>事件分发：捕获/冒泡、阻止传播、手势系统</li></ul><h4 id="算法示意-scene-graph-的命中-层级-变换-z-order" tabindex="-1">算法示意：scene graph 的命中（层级 + 变换 + z-order） <a class="header-anchor" href="#算法示意-scene-graph-的命中-层级-变换-z-order" aria-label="Permalink to &quot;算法示意：scene graph 的命中（层级 + 变换 + z-order）&quot;">​</a></h4><p>当你进入 Canvas/WebGL 路线，hit testing 通常不再是“在 DOM 上查”，而是“在场景树上查”：</p><ol><li>展开可命中对象集合（或在树上递归）</li><li>按绘制顺序/层级排序（通常 z 越大越靠前）</li><li>从前到后测试：矩形包含、路径包含、或像素级（mask）命中</li></ol><p>工程上最容易被忽略的细节是“变换”：</p><ul><li>渲染时你可能对节点做了 translate/scale/rotate</li><li>命中时你要么把点 (x,y) 逆变换到节点局部坐标系，要么把节点边界变换到屏幕坐标系</li></ul><p>一旦你把变换当成一等公民，很多“点不准”的问题会从玄学变回数学。</p><h3 id="从命中到交互-事件系统与闭环" tabindex="-1">从命中到交互：事件系统与闭环 <a class="header-anchor" href="#从命中到交互-事件系统与闭环" aria-label="Permalink to &quot;从命中到交互：事件系统与闭环&quot;">​</a></h3><p>只把点位映射到位置（node/offset）还不够：用户的真实交互不是“点击一次”，而是一段连续的输入序列（按下 → 移动 → 抬起、双击、长按、拖拽、滚轮、按键、组合键）。</p><p>如果你用的是 DOM 渲染，浏览器帮你做了大量工作：事件目标、捕获/冒泡、pointer capture、默认行为、手势与滚动竞争。只要你走向 Canvas/WebGL/Hybrid，你就必须自己补齐这一层，否则你会遇到：</p><ul><li>拖拽过程中目标漂移：按下命中 A，拖到 B，事件突然投递给 B</li><li>选区拖拽不稳定：移动时命中结果抖动，导致选区“跳格子”</li><li>手势冲突：滚动、缩放、选区、拖拽互相抢控制权</li><li>插件不可治理：谁先处理事件、谁能拦截、如何观测，一团浆糊</li></ul><h4 id="事件系统的三件事-目标、路径、时序" tabindex="-1">事件系统的三件事：目标、路径、时序 <a class="header-anchor" href="#事件系统的三件事-目标、路径、时序" aria-label="Permalink to &quot;事件系统的三件事：目标、路径、时序&quot;">​</a></h4><p>把“事件系统”拆成三件事，会更工程化：</p><ol><li>目标：每次输入发生时，到底命中哪个可交互对象（Hit Target）</li><li>路径：事件如何在对象层级中传播（捕获/冒泡、可中断）</li><li>时序：一段交互序列如何保持一致性（pointer capture、手势状态机）</li></ol><h5 id="目标-从-x-y-到命中目标-hit-target" tabindex="-1">目标：从 (x, y) 到命中目标（Hit Target） <a class="header-anchor" href="#目标-从-x-y-到命中目标-hit-target" aria-label="Permalink to &quot;目标：从 (x, y) 到命中目标（Hit Target）&quot;">​</a></h5><p>当你有 scene graph 之后，hit testing 的输出就不该只是一段 “doc position”，而应该能命中“交互对象”：</p><ul><li>文档对象：段落、行内文本、图片、表格单元格</li><li>装饰器对象：批注高亮、链接 underline、协同光标</li><li>控件对象：resize handle、drag handle、浮层按钮</li></ul><p>更稳的做法是让命中返回一个结构化结果：</p><ul><li>targetId：命中的对象 id</li><li>kind：text / node / decoration / handle</li><li>position：在文档模型里的位置（如果有）</li><li>localPoint：在对象局部坐标系下的点（用于拖拽/路径命中）</li><li>hitPath：从根到目标的对象链（用于传播）</li></ul><h5 id="路径-捕获-冒泡不是-dom-专属-而是可治理性基础" tabindex="-1">路径：捕获/冒泡不是“DOM 专属”，而是可治理性基础 <a class="header-anchor" href="#路径-捕获-冒泡不是-dom-专属-而是可治理性基础" aria-label="Permalink to &quot;路径：捕获/冒泡不是“DOM 专属”，而是可治理性基础&quot;">​</a></h5><p>捕获/冒泡的价值不是“和浏览器一致”，而是两点：</p><ul><li>给“全局能力”一个稳定入口（例如：选区系统、手势系统、快捷键系统）</li><li>给“局部能力”一个稳定边界（例如：表格内的拖拽规则不应污染全局）</li></ul><p>在 scene graph 里，你可以把传播路径定义为 hitPath：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Root → Page → Paragraph → InlineRun → Link</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后实现两段分发：</p><ul><li>capture：Root → … → target</li><li>bubble：target → … → Root</li></ul><p>每个 handler 都有机会返回一个结果：</p><ul><li>handled：是否消费</li><li>stopPropagation：是否停止传播</li><li>preventDefault：是否阻止默认行为（例如：系统滚动、浏览器选择）</li></ul><h5 id="时序-pointer-capture-与手势状态机-让交互-有始有终" tabindex="-1">时序：pointer capture 与手势状态机，让交互“有始有终” <a class="header-anchor" href="#时序-pointer-capture-与手势状态机-让交互-有始有终" aria-label="Permalink to &quot;时序：pointer capture 与手势状态机，让交互“有始有终”&quot;">​</a></h5><p>拖拽/选区/缩放的关键是：从 pointerdown 到 pointerup，这段序列必须属于同一个交互上下文。</p><p>两条最常用的工程约定：</p><ol><li>pointer capture（概念层）</li></ol><p>pointerdown 命中哪个对象，就把 pointerId 捕获到它（或捕获到一个更高层的“交互控制器”），直到 pointerup/cancel 释放。这样就能保证：</p><ul><li>移动时即使命中漂移，事件也不会“转投”</li><li>选区拖拽不会被中途命中到的其他控件抢走</li></ul><ol start="2"><li>手势状态机（实现层）</li></ol><p>把交互意图显式建模成状态机，而不是散落的 if/else：</p>',67)),r(t,{codeBase64:"c3RhdGVEaWFncmFtLXYyCiAgWypdIC0tPiDnqbrpl7IKICDnqbrpl7IgLS0+IOaMieS4i+S4rTogcG9pbnRlcmRvd24KICDmjInkuIvkuK0gLS0+IOaLlumAieS4rTog56e75YqoID4g6ZiI5YC8CiAg5oyJ5LiL5LitIC0tPiDngrnlh7vkuK06IHBvaW50ZXJ1cAogIOaLlumAieS4rSAtLT4g6Ieq5Yqo5rua5YqoOiDpnaDov5HovrnnvJgKICDoh6rliqjmu5rliqggLS0+IOaLlumAieS4rTog56a75byA6L6557yYCiAg5ouW6YCJ5LitIC0tPiDnqbrpl7I6IHBvaW50ZXJ1cAogIOeCueWHu+S4rSAtLT4g56m66ZeyOiDlrozmiJAK"}),a[4]||(a[4]=i('<p>你可以用同一套状态机处理：</p><ul><li>文本选区（drag select）</li><li>节点拖拽（drag node）</li><li>手柄调整（resize)</li><li>双击/三击的时间窗口（tap sequence）</li></ul><h3 id="工程实践-性能、异常与可调试性" tabindex="-1">工程实践：性能、异常与可调试性 <a class="header-anchor" href="#工程实践-性能、异常与可调试性" aria-label="Permalink to &quot;工程实践：性能、异常与可调试性&quot;">​</a></h3><h4 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h4><ul><li>几何缓存：hit test 依赖几何；几何必须缓存且可增量更新</li><li>索引：行二分 + 行内二分是最稳定的基线；对象命中再引入空间索引</li><li>分层：文本层/装饰层/交互层分开索引，避免互相拖累</li></ul><p>再补两条“写过才知道”的经验：</p><ol><li>虚拟化会把 hit testing 逼成一个系统问题</li></ol><p>当你只渲染视口内的 DOM/图元时，屏幕上的对象不再等价于文档里的对象。你必须回答：</p><ul><li>点击发生在未渲染区域怎么办？（通常需要把点击映射到“逻辑行/逻辑块”，再触发局部渲染）</li><li>selection 跨视口怎么办？（需要用几何缓存生成 rect，或分段渲染 overlay）</li></ul><p>比喻一下：虚拟化就像你只把图书馆的“热门书”摆在书架上，其他都在仓库。用户来问“第 1000 本书在哪”，你不能说“我书架上没有”。你得有索引与仓库调度机制。</p><ol start="2"><li>2D 空间索引的选择本质是“更新频率 vs 查询频率”</li></ol><p>编辑器里命中对象（图片、批注气泡、手柄）常见三种组织方式：</p><ul><li>网格 hash：把屏幕分成格子，每个对象登记进覆盖的格子；更新与查询都很快，适合动态对象多</li><li>R-Tree：更通用，但实现复杂，更新成本更高</li><li>分层索引：先按 y 找行/段，再在局部做 x 查询；适合“文本为主”的编辑器</li></ul><p>四舍五入：索引结构没有银弹，选择的关键是你能不能把“对象变化范围”限制在局部。</p><h4 id="异常" tabindex="-1">异常 <a class="header-anchor" href="#异常" aria-label="Permalink to &quot;异常&quot;">​</a></h4><ul><li>字体加载变化：metrics 变化会导致 hit test 偏移，需要重排/重建索引</li><li>设备像素比：渲染空间与事件空间不一致时，“看起来准、点起来不准”</li><li>输入法：composition 下 selection 的规则更复杂，hit test 的输出需要能表达 IME 状态</li></ul><p>再补一个经典坑：坐标系不一致。</p><ul><li>DOM 事件给你的是 clientX/clientY（视口坐标）</li><li>Canvas/WebGL 里你可能在用设备像素坐标（乘了 DPR）</li><li>你还可能有滚动偏移、缩放、旋转（transform）</li></ul><p>如果你不把“坐标系转换”当成明确模块来做，点不准会变成长期存在的幽灵 bug。最稳的策略是：在 hit testing 的入口就把坐标统一到同一个空间（例如文档空间或渲染空间），然后整条链路都只认这一种坐标。</p><h4 id="默认行为-事件系统必须明确-谁说了算" tabindex="-1">默认行为：事件系统必须明确“谁说了算” <a class="header-anchor" href="#默认行为-事件系统必须明确-谁说了算" aria-label="Permalink to &quot;默认行为：事件系统必须明确“谁说了算”&quot;">​</a></h4><p>浏览器环境里有很多默认行为：滚动、文本选择、双击选词、长按菜单、拖拽图片、输入法候选。编辑器的事件系统必须明确每条交互的裁决权：</p><ul><li>什么时候应该 <code>preventDefault</code>，把控制权接管到编辑器</li><li>什么时候应该放行，让系统行为发生（尤其移动端的滚动与回弹）</li></ul><p>更稳的经验是把“默认行为策略”当成产品逻辑，而不是写死在事件处理函数里：</p><ul><li>文本拖拽选区：接管</li><li>两指滚动：放行（或在白板类产品里接管为平移画布）</li><li>Ctrl/Meta + wheel：接管为缩放（或放行为页面缩放，取决于产品定位）</li></ul><p>当策略明确后，bug 会从“玄学”变成“某条规则写错了”。</p><h4 id="选区与复制-命中只是开始-后面还有一连串-系统约定" tabindex="-1">选区与复制：命中只是开始，后面还有一连串“系统约定” <a class="header-anchor" href="#选区与复制-命中只是开始-后面还有一连串-系统约定" aria-label="Permalink to &quot;选区与复制：命中只是开始，后面还有一连串“系统约定”&quot;">​</a></h4><p>很多人实现 hit testing 后会觉得“点准了”，但用户会立刻暴露下一个问题：拖拽选区、双击选词、三击选段、复制粘贴、以及跨节点选择。在 DOM 路线里，这些行为很多是浏览器默认实现；在 Canvas/WebGL 路线里，你要自己把它们变成一套一致的规则。</p><p>更工程化的拆法是把选择系统分成三层：</p><ul><li><strong>输入层</strong>：pointer/keyboard/IME 事件转换成选择意图（start/extend/word/line）</li><li><strong>几何层</strong>：把选择意图映射成一组 rect（用于绘制高亮与 handle）</li><li><strong>模型层</strong>：把选择最终落在 (node, offset) 的区间，并能稳定地映射（transaction 后仍然可追踪）</li></ul><p>四舍五入：hit testing 是“从像素到位置”的入口，但真正让编辑器像编辑器的，是你能不能把这个入口连接到选择、复制、输入法、以及可访问性这些系统级约定上。</p><h4 id="调试手段-把命中结果可视化-否则你只能靠猜" tabindex="-1">调试手段：把命中结果可视化，否则你只能靠猜 <a class="header-anchor" href="#调试手段-把命中结果可视化-否则你只能靠猜" aria-label="Permalink to &quot;调试手段：把命中结果可视化，否则你只能靠猜&quot;">​</a></h4><p>hit testing 的 bug 往往很难用日志说明白，因为它发生在几何层：差 2px，用户就会觉得“点不准”。更稳的排障方式是提供可视化开关，把关键中间结果画出来：</p><ul><li>点击点位与坐标空间（视口坐标/渲染坐标/文档坐标）</li><li>命中的行盒范围与基线</li><li>命中的 glyph cluster 边界（以及最终选择的插入点）</li></ul><p>当这些辅助线能被画在屏幕上，你调试的对象就从“感觉”变成“几何事实”。四舍五入：命中系统越复杂，可视化工具越是必需品。</p><h4 id="坐标统一-dpr、滚动与变换可以写成一条公式" tabindex="-1">坐标统一：DPR、滚动与变换可以写成一条公式 <a class="header-anchor" href="#坐标统一-dpr、滚动与变换可以写成一条公式" aria-label="Permalink to &quot;坐标统一：DPR、滚动与变换可以写成一条公式&quot;">​</a></h4><p>很多“点不准”问题，本质都是坐标空间混用了：事件坐标是 CSS 像素，Canvas 内部是设备像素，文档又有自己的滚动与缩放。更稳的做法是把入口统一成一条公式，哪怕你不写矩阵，也要在脑子里有这条链路：</p><ul><li>p_viewport = (clientX, clientY)</li><li>p_canvas = (clientX - canvasLeft, clientY - canvasTop)</li><li>p_device = p_canvas · DPR</li><li>p_doc = Inverse(ViewTransform) · p_device</li></ul><p>你不一定需要真的用矩阵实现，但你必须在系统里明确 ViewTransform 包含哪些东西（滚动、缩放、旋转、分页偏移）。一旦这条链路清晰，hit testing 的每一步都能说清楚“我当前在哪个空间”，点不准就不再是玄学，而是某一项变换漏乘或重复乘了。</p><h4 id="性能视角-命中查询必须-越常用越便宜" tabindex="-1">性能视角：命中查询必须“越常用越便宜” <a class="header-anchor" href="#性能视角-命中查询必须-越常用越便宜" aria-label="Permalink to &quot;性能视角：命中查询必须“越常用越便宜”&quot;">​</a></h4><p>hit testing 不是偶尔才调用的功能，它会在拖拽选区、移动光标、手柄调整、甚至 hover 高亮里被高频触发。更危险的是：它的性能问题很容易被误判为“渲染慢”，因为用户感知到的就是卡顿与延迟。</p><p>因此更稳的工程策略是把命中查询分级：</p><ul><li>最常用路径（行二分 + 行内二分）必须走纯内存数据结构，且尽量零分配</li><li>对象命中（图片/手柄/批注气泡）要能在局部索引里快速裁剪候选集</li><li>像素级命中（mask/path）只能作为最后一层兜底，否则成本不可控</li></ul><p>你可以把它类比成搜索引擎：先用倒排索引缩小候选，再在候选里做精排。命中系统也一样：先用 y 定位到行/段的候选集合，再在局部里做更精细的判断。四舍五入：把高频路径做得足够便宜，你才能放心在交互层不断调用它，而不是到处加节流与缓存补丁。</p><p>同样地，命中系统也应该有“降级策略”：当几何缓存失效、字体尚未加载完成、或某些对象索引缺失时，允许返回一个保守但稳定的结果（例如落到最近行首/行尾），并触发异步重建缓存。宁愿短暂不够精确，也不要返回跳来跳去的落点，因为后者会直接击穿用户信任。</p><h3 id="参考与引用" tabindex="-1">参考与引用 <a class="header-anchor" href="#参考与引用" aria-label="Permalink to &quot;参考与引用&quot;">​</a></h3><ol><li>Pointer Events：<a href="https://www.w3.org/TR/pointerevents/" target="_blank" rel="noreferrer">https://www.w3.org/TR/pointerevents/</a> （Bib: <code>pointer_events</code>）</li><li>Canvas 2D API：<a href="https://html.spec.whatwg.org/multipage/canvas.html" target="_blank" rel="noreferrer">https://html.spec.whatwg.org/multipage/canvas.html</a> （Bib: <code>whatwg_canvas</code>）</li><li>WebGL Specification：<a href="https://registry.khronos.org/webgl/specs/latest/1.0/" target="_blank" rel="noreferrer">https://registry.khronos.org/webgl/specs/latest/1.0/</a> （Bib: <code>webgl_spec</code>）</li><li>WebGPU Specification：<a href="https://www.w3.org/TR/webgpu/" target="_blank" rel="noreferrer">https://www.w3.org/TR/webgpu/</a> （Bib: <code>webgpu_spec</code>）</li></ol>',46))])}const v=n(h,[["render",c]]);export{y as __pageData,v as default};
