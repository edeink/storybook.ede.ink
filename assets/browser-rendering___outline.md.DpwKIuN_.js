import{f as r,c as a,o as i,a4 as l}from"./chunks/framework.BAs4fWuZ.js";const m=JSON.parse('{"title":"浏览器渲染与 Chromium 架构：专题大纲","description":"","frontmatter":{"title":"浏览器渲染与 Chromium 架构：专题大纲"},"headers":[],"relativePath":"browser-rendering/__outline.md","filePath":"browser-rendering/__outline.md","lastUpdated":1769026429000}'),o={name:"browser-rendering/__outline.md"};function t(s,e,n,c,h,d){return i(),a("div",null,[...e[0]||(e[0]=[l('<h2 id="_0-范围与口径-先把地图画对" tabindex="-1">0. 范围与口径（先把地图画对） <a class="header-anchor" href="#_0-范围与口径-先把地图画对" aria-label="Permalink to &quot;0. 范围与口径（先把地图画对）&quot;">​</a></h2><ul><li>目标：把 Chromium 的“网页 → 像素”链路拆开讲透，让前端遇到卡顿/掉帧/延迟时能把锅精准甩回某个阶段（以及知道怎么甩得动）</li><li>主线：Chromium（Browser/Renderer/GPU/Network）+ Blink（DOM/CSS/Layout/Paint）+ cc/Viz（Compositor）+ Skia（Raster）+ V8（JS/GC）</li><li>约束：尽量讲实现与数据结构，不做百科；遇到分支实现（平台差异/版本演进）会明确标注“倾向/可能/待核对”</li><li>前端映射：每一章尽量回答两个问题 <ul><li>这块在 Chromium 里是谁干的、在哪个线程/进程里干</li><li>我写的 JS/CSS/Canvas/WebGPU，怎么把它推成某种具体的成本</li></ul></li></ul><h2 id="_1-总览-从输入到上屏的一帧-把-因果链-画出来" tabindex="-1">1. 总览：从输入到上屏的一帧（把“因果链”画出来） <a class="header-anchor" href="#_1-总览-从输入到上屏的一帧-把-因果链-画出来" aria-label="Permalink to &quot;1. 总览：从输入到上屏的一帧（把“因果链”画出来）&quot;">​</a></h2><p>![[browser-rendering-01-big-picture.png]]</p><h3 id="_1-1-最小模型-一帧到底由哪些阶段组成" tabindex="-1">1.1 最小模型：一帧到底由哪些阶段组成 <a class="header-anchor" href="#_1-1-最小模型-一帧到底由哪些阶段组成" aria-label="Permalink to &quot;1.1 最小模型：一帧到底由哪些阶段组成&quot;">​</a></h3><ul><li>JS：事件回调、框架调度、数据计算</li><li>Blink：style → layout → paint（产出可绘制的中间表示）</li><li>cc：commit/activate/draw（把“图层/属性树”组织成一帧）</li><li>Skia：raster（把绘制指令栅格化成瓦片/位图/纹理）</li><li>Viz/GPU：合成、overlay、swap，上屏与 buffer 管线</li></ul><h3 id="_1-2-进程-线程-前端能看到的-主线程-在-chromium-里只是其中一条" tabindex="-1">1.2 进程 + 线程：前端能看到的“主线程”，在 Chromium 里只是其中一条 <a class="header-anchor" href="#_1-2-进程-线程-前端能看到的-主线程-在-chromium-里只是其中一条" aria-label="Permalink to &quot;1.2 进程 + 线程：前端能看到的“主线程”，在 Chromium 里只是其中一条&quot;">​</a></h3><p>![[browser-rendering-02-process-thread-map.png]]</p><ul><li>进程（高层）：Browser / Renderer / GPU / Network / Utility</li><li>Renderer（关键）：Main thread（Blink + V8）/ Compositor thread（cc）/ Raster worker threads（栅格化）/ Worker threads（WebWorker）</li><li>直觉修正：把逻辑挪到 Worker 往往只是在“挪走 JS”，不会自动减少 style/layout/paint 的硬成本</li></ul><h2 id="_2-chromium-架构-多进程、mojo、站点隔离-先把边界搞清楚" tabindex="-1">2. Chromium 架构：多进程、Mojo、站点隔离（先把边界搞清楚） <a class="header-anchor" href="#_2-chromium-架构-多进程、mojo、站点隔离-先把边界搞清楚" aria-label="Permalink to &quot;2. Chromium 架构：多进程、Mojo、站点隔离（先把边界搞清楚）&quot;">​</a></h2><h3 id="_2-1-为什么要多进程-安全、稳定、并行" tabindex="-1">2.1 为什么要多进程：安全、稳定、并行 <a class="header-anchor" href="#_2-1-为什么要多进程-安全、稳定、并行" aria-label="Permalink to &quot;2.1 为什么要多进程：安全、稳定、并行&quot;">​</a></h3><ul><li>Browser process：导航、窗口、权限、进程管理、调度中枢</li><li>Renderer process：Blink + V8，解析/执行/布局/绘制的“网页工厂”</li><li>GPU process：图形驱动隔离、命令提交、合成与显示路径的一部分</li><li>Network service：网络栈与缓存（架构上可独立于 Browser）</li></ul><h3 id="_2-2-frame-tree-site-isolation-oopif-对前端最-反直觉-的一层" tabindex="-1">2.2 Frame Tree / Site Isolation / OOPIF（对前端最“反直觉”的一层） <a class="header-anchor" href="#_2-2-frame-tree-site-isolation-oopif-对前端最-反直觉-的一层" aria-label="Permalink to &quot;2.2 Frame Tree / Site Isolation / OOPIF（对前端最“反直觉”的一层）&quot;">​</a></h3><ul><li>关键点：同一个 tab 里可能存在多个 renderer process（跨站 iframe 更常见）</li><li>影响面：输入事件路由、合成 surface、同步点、性能归因（“卡的是哪个 renderer”）</li></ul><h3 id="_2-3-viz-为什么你在-chromium-源码里总能看见它" tabindex="-1">2.3 Viz：为什么你在 Chromium 源码里总能看见它 <a class="header-anchor" href="#_2-3-viz-为什么你在-chromium-源码里总能看见它" aria-label="Permalink to &quot;2.3 Viz：为什么你在 Chromium 源码里总能看见它&quot;">​</a></h3><ul><li>粗暴理解：Viz 负责把多个 renderer 产出的“CompositorFrame”拼成最终屏幕画面，并与平台显示系统对接</li></ul><h2 id="_3-renderer-内部-blink-v8-scheduler-的-分工与拉扯" tabindex="-1">3. Renderer 内部：Blink / V8 / Scheduler 的“分工与拉扯” <a class="header-anchor" href="#_3-renderer-内部-blink-v8-scheduler-的-分工与拉扯" aria-label="Permalink to &quot;3. Renderer 内部：Blink / V8 / Scheduler 的“分工与拉扯”&quot;">​</a></h2><h3 id="_3-1-blink-的-lifecycle-从-dom-变更到可绘制中间表示" tabindex="-1">3.1 Blink 的 Lifecycle（从 DOM 变更到可绘制中间表示） <a class="header-anchor" href="#_3-1-blink-的-lifecycle-从-dom-变更到可绘制中间表示" aria-label="Permalink to &quot;3.1 Blink 的 Lifecycle（从 DOM 变更到可绘制中间表示）&quot;">​</a></h3><p>![[browser-rendering-03-lifecycle.png]]</p><ul><li>style recalc：选择器匹配与无效化（invalidations）</li><li>layout：flow + fragments（包含滚动、视口裁剪、增量布局的现实）</li><li>paint：生成 paint artifact / display items（可被缓存与复用）</li></ul><h3 id="_3-2-scheduler-为什么同样的代码-在不同机器-负载下表现不一样" tabindex="-1">3.2 Scheduler：为什么同样的代码，在不同机器/负载下表现不一样 <a class="header-anchor" href="#_3-2-scheduler-为什么同样的代码-在不同机器-负载下表现不一样" aria-label="Permalink to &quot;3.2 Scheduler：为什么同样的代码，在不同机器/负载下表现不一样&quot;">​</a></h3><ul><li>主线程不仅跑 JS：它还要跑 Blink 的多个阶段，以及各种“系统性任务”（比如 GC、解析、微任务）</li><li>一些任务会被切片/延后/合并，导致你在 DevTools 里看到的时间线并不总是直觉那样线性</li></ul><h2 id="_4-合成-cc-与上屏-composite-不是-最后一步-而是一套体系" tabindex="-1">4. 合成（cc）与上屏：Composite 不是“最后一步”，而是一套体系 <a class="header-anchor" href="#_4-合成-cc-与上屏-composite-不是-最后一步-而是一套体系" aria-label="Permalink to &quot;4. 合成（cc）与上屏：Composite 不是“最后一步”，而是一套体系&quot;">​</a></h2><h3 id="_4-1-核心对象-layer-tree-property-trees-surface" tabindex="-1">4.1 核心对象：Layer Tree / Property Trees / Surface <a class="header-anchor" href="#_4-1-核心对象-layer-tree-property-trees-surface" aria-label="Permalink to &quot;4.1 核心对象：Layer Tree / Property Trees / Surface&quot;">​</a></h3><ul><li>Layer Tree：哪些东西能独立合成、哪些必须重绘</li><li>Property Trees：transform/clip/effect/scroll 的层级与继承（合成阶段要用来算最终状态）</li><li>Surface：跨进程合成的“拼接单位”</li></ul><h3 id="_4-2-commit-activate-draw-两棵树与同步点" tabindex="-1">4.2 Commit / Activate / Draw：两棵树与同步点 <a class="header-anchor" href="#_4-2-commit-activate-draw-两棵树与同步点" aria-label="Permalink to &quot;4.2 Commit / Activate / Draw：两棵树与同步点&quot;">​</a></h3><p>![[browser-rendering-04-cc-pipeline.png]]</p><ul><li>Pending tree：主线程提交过来的最新状态</li><li>Active tree：当前正在用于 draw 的状态</li><li>同步点：commit/activate 往往是 jank 的“硬拐点”，也是优化最难的地方之一</li></ul><h3 id="_4-3-合成友好-compositor-only-的边界-前端最该记住的一页纸" tabindex="-1">4.3 合成友好（compositor-only）的边界：前端最该记住的一页纸 <a class="header-anchor" href="#_4-3-合成友好-compositor-only-的边界-前端最该记住的一页纸" aria-label="Permalink to &quot;4.3 合成友好（compositor-only）的边界：前端最该记住的一页纸&quot;">​</a></h3><ul><li>倾向上只改 transform/opacity 更容易留在合成线程，避免主线程重排/重绘</li><li>但“变合成”不是免费：layer 增多会带来更高的内存与栅格化压力，甚至把瓶颈推到 GPU</li></ul><h2 id="_5-raster-skia-paint-之后发生了什么-为什么会有瓦片-纹理预算" tabindex="-1">5. Raster &amp; Skia：Paint 之后发生了什么（为什么会有瓦片/纹理预算） <a class="header-anchor" href="#_5-raster-skia-paint-之后发生了什么-为什么会有瓦片-纹理预算" aria-label="Permalink to &quot;5. Raster &amp; Skia：Paint 之后发生了什么（为什么会有瓦片/纹理预算）&quot;">​</a></h2><h3 id="_5-1-display-list-→-tiles-为什么-chromium-要瓦片化" tabindex="-1">5.1 Display list → tiles：为什么 Chromium 要瓦片化 <a class="header-anchor" href="#_5-1-display-list-→-tiles-为什么-chromium-要瓦片化" aria-label="Permalink to &quot;5.1 Display list → tiles：为什么 Chromium 要瓦片化&quot;">​</a></h3><ul><li>目的：把大页面拆成小块，只重栅格化受影响区域</li><li>代价：tile 管理、优先级、抢占、缓存失效都会产生复杂度</li></ul><h3 id="_5-2-skia-的角色-2d-绘制与后端抽象" tabindex="-1">5.2 Skia 的角色：2D 绘制与后端抽象 <a class="header-anchor" href="#_5-2-skia-的角色-2d-绘制与后端抽象" aria-label="Permalink to &quot;5.2 Skia 的角色：2D 绘制与后端抽象&quot;">​</a></h3><ul><li>你可以把 Skia 当成 Chromium 的“统一画笔”：路径、文本、滤镜、图像解码后的绘制入口都可能落到它</li><li>后端：CPU raster / GPU raster（随平台与配置变化，细节以实现为准）</li></ul><h3 id="_5-3-gpu-进程与显示-buffer、overlay、swap-的现实约束" tabindex="-1">5.3 GPU 进程与显示：buffer、overlay、swap 的现实约束 <a class="header-anchor" href="#_5-3-gpu-进程与显示-buffer、overlay、swap-的现实约束" aria-label="Permalink to &quot;5.3 GPU 进程与显示：buffer、overlay、swap 的现实约束&quot;">​</a></h3><ul><li>纹理预算：图片、canvas、视频帧、字形缓存都在抢显存</li><li>overlay：绕过合成、直接走硬件叠加可能极省，但需要满足一堆条件（平台相关）</li></ul><h2 id="_6-输入与延迟-事件如何穿过多进程管线" tabindex="-1">6. 输入与延迟：事件如何穿过多进程管线 <a class="header-anchor" href="#_6-输入与延迟-事件如何穿过多进程管线" aria-label="Permalink to &quot;6. 输入与延迟：事件如何穿过多进程管线&quot;">​</a></h2><p>![[browser-rendering-05-input-latency.png]]</p><ul><li>输入路由：Browser 侧收 → 找到目标 renderer → 命中/分发</li><li>滚动：能在 compositor thread 处理的就尽量别上主线程（否则容易变“滚不动”）</li><li>命中：hit test 数据结构与更新时机，决定了交互延迟的下限</li></ul><h2 id="_7-v8-面向前端的实现细节-你写的-js-怎么变成-时间线上的那条火焰" tabindex="-1">7. V8（面向前端的实现细节）：你写的 JS 怎么变成“时间线上的那条火焰” <a class="header-anchor" href="#_7-v8-面向前端的实现细节-你写的-js-怎么变成-时间线上的那条火焰" aria-label="Permalink to &quot;7. V8（面向前端的实现细节）：你写的 JS 怎么变成“时间线上的那条火焰”&quot;">​</a></h2><h3 id="_7-1-执行与优化-hiddenclass-inline-cache-分层编译" tabindex="-1">7.1 执行与优化：HiddenClass / Inline Cache / 分层编译 <a class="header-anchor" href="#_7-1-执行与优化-hiddenclass-inline-cache-分层编译" aria-label="Permalink to &quot;7.1 执行与优化：HiddenClass / Inline Cache / 分层编译&quot;">​</a></h3><ul><li>对象形状（HiddenClass）稳定性与 IC 命中，决定了“这段 JS 是不是能跑在高速路上”</li><li>分层编译（解释器/基线/优化编译器）与 deopt，决定了抖动的来源与复现难度</li></ul><h3 id="_7-2-gc-为什么-逻辑没变-但就是偶发卡一下" tabindex="-1">7.2 GC：为什么“逻辑没变，但就是偶发卡一下” <a class="header-anchor" href="#_7-2-gc-为什么-逻辑没变-但就是偶发卡一下" aria-label="Permalink to &quot;7.2 GC：为什么“逻辑没变，但就是偶发卡一下”&quot;">​</a></h3><ul><li>关键点：增量/并发/分代回收把暂停切碎，但并不意味着暂停消失</li><li>关联前端：大对象/ArrayBuffer/TypedArray、频繁分配、跨线程传输，都可能把 GC 压力放大</li></ul><h3 id="_7-3-event-loop-microtasks-raf-调度层的三角关系" tabindex="-1">7.3 Event loop / microtasks / rAF：调度层的三角关系 <a class="header-anchor" href="#_7-3-event-loop-microtasks-raf-调度层的三角关系" aria-label="Permalink to &quot;7.3 Event loop / microtasks / rAF：调度层的三角关系&quot;">​</a></h3><ul><li>microtasks（Promise）会在某些边界点清空，导致“看起来很小的 then 链”吞掉一帧</li><li>rAF 是渲染节拍的入口，但它不保证你 16.6ms 内一定交卷</li></ul><h2 id="_8-worker-体系-把计算挪走-还是把渲染也挪走" tabindex="-1">8. Worker 体系：把计算挪走，还是把渲染也挪走 <a class="header-anchor" href="#_8-worker-体系-把计算挪走-还是把渲染也挪走" aria-label="Permalink to &quot;8. Worker 体系：把计算挪走，还是把渲染也挪走&quot;">​</a></h2><h3 id="_8-1-worker-家族-dedicated-shared-service-worker" tabindex="-1">8.1 Worker 家族：Dedicated / Shared / Service Worker <a class="header-anchor" href="#_8-1-worker-家族-dedicated-shared-service-worker" aria-label="Permalink to &quot;8.1 Worker 家族：Dedicated / Shared / Service Worker&quot;">​</a></h3><ul><li>Dedicated Worker：最常见的“把计算挪走”</li><li>Shared Worker：多页面共享（现实里更少用）</li><li>Service Worker：更像网络/缓存/离线层的“中间件”，不直接参与渲染</li></ul><h3 id="_8-2-为什么-上-worker-不等于-渲染变快" tabindex="-1">8.2 为什么“上 Worker”不等于“渲染变快” <a class="header-anchor" href="#_8-2-为什么-上-worker-不等于-渲染变快" aria-label="Permalink to &quot;8.2 为什么“上 Worker”不等于“渲染变快”&quot;">​</a></h3><ul><li>DOM/CSSOM 属于主线程上的 Blink 世界，Worker 不能直接触碰</li><li>如果瓶颈在 layout/paint/composite/raster/GPU，把 JS 挪走往往只是把时间线换了个颜色</li></ul><h3 id="_8-3-offscreencanvas-少数能让-worker-参与-画画-的路径" tabindex="-1">8.3 OffscreenCanvas：少数能让 Worker 参与“画画”的路径 <a class="header-anchor" href="#_8-3-offscreencanvas-少数能让-worker-参与-画画-的路径" aria-label="Permalink to &quot;8.3 OffscreenCanvas：少数能让 Worker 参与“画画”的路径&quot;">​</a></h3><ul><li>关键点：传输成本（structured clone / Transferable / SharedArrayBuffer）决定上限</li><li>失败场景：每帧传大数组/大图像，在消息通道上把收益吃光</li></ul><h2 id="_9-前端可操作的优化面-哪些手段对应哪条管线" tabindex="-1">9. 前端可操作的优化面：哪些手段对应哪条管线 <a class="header-anchor" href="#_9-前端可操作的优化面-哪些手段对应哪条管线" aria-label="Permalink to &quot;9. 前端可操作的优化面：哪些手段对应哪条管线&quot;">​</a></h2><h3 id="_9-1-css-dom-改动的-成本对照表-先背规律-再看-trace" tabindex="-1">9.1 CSS/DOM 改动的“成本对照表”（先背规律，再看 trace） <a class="header-anchor" href="#_9-1-css-dom-改动的-成本对照表-先背规律-再看-trace" aria-label="Permalink to &quot;9.1 CSS/DOM 改动的“成本对照表”（先背规律，再看 trace）&quot;">​</a></h3><ul><li>强制同步布局：读 layout 信息触发 flush（layout thrash）</li><li>绘制变贵：阴影/滤镜/透明叠加/大面积 clip/path</li><li>合成变贵：layer 爆炸、过大纹理、过多视频/画布同时存在</li><li>通信变贵：Worker 每帧传大对象/大数组（序列化/拷贝/同步点）</li></ul><h3 id="_9-2-工具箱-哪些-api-属性更接近-合成友好" tabindex="-1">9.2 工具箱：哪些 API/属性更接近“合成友好” <a class="header-anchor" href="#_9-2-工具箱-哪些-api-属性更接近-合成友好" aria-label="Permalink to &quot;9.2 工具箱：哪些 API/属性更接近“合成友好”&quot;">​</a></h3><ul><li>transform/opacity 动画（倾向更容易 compositor-only）</li><li>containment / content-visibility（倾向减少无效化传播）</li><li>IntersectionObserver / ResizeObserver（用对能减少强制同步读取的冲动）</li></ul><h2 id="_11-章节清单-按-order-topic-md-命名" tabindex="-1">11. 章节清单（按 <code>[order]-[topic].md</code> 命名） <a class="header-anchor" href="#_11-章节清单-按-order-topic-md-命名" aria-label="Permalink to &quot;11. 章节清单（按 `[order]-[topic].md` 命名）&quot;">​</a></h2><ul><li>01-chromium-architecture-processes-and-threads.md：Chromium 架构总览：多进程与线程模型</li><li>02-blink-lifecycle-style-layout-paint.md：Blink 生命周期：style/layout/paint 与无效化</li><li>03-cc-compositor-commit-activate-draw.md：cc 合成体系：两棵树、属性树与同步点</li><li>04-viz-gpu-and-present-to-screen.md：Viz/GPU/上屏：surface、buffer 与显示路径</li><li>05-input-latency-scroll-and-hit-test.md：输入与滚动：事件路由、命中与延迟下限</li><li>06-v8-for-frontend-hiddenclass-ic-gc.md：V8 细节（前端视角）：优化、deopt 与 GC</li><li>07-workers-offscreen-canvas-and-transfer-cost.md：Worker：收益边界、OffscreenCanvas 与通信成本</li><li>08-performance-tracing-devtools-perfetto.md：可观测：DevTools、Tracing/Perfetto 与归因方法</li><li>09-frontend-levers-css-composite-paint-budget.md：前端对照表：哪些写法对应哪条渲染管线</li></ul><h2 id="_12-参考与扩展阅读-以-chromium-为主" tabindex="-1">12. 参考与扩展阅读（以 Chromium 为主） <a class="header-anchor" href="#_12-参考与扩展阅读-以-chromium-为主" aria-label="Permalink to &quot;12. 参考与扩展阅读（以 Chromium 为主）&quot;">​</a></h2><ul><li>A Pixel（从输入到上屏的一帧）<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_1003" target="_blank" rel="noreferrer">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_1003</a></li><li>Chromium docs（架构与子系统入口）<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/" target="_blank" rel="noreferrer">https://chromium.googlesource.com/chromium/src/+/main/docs/</a></li><li>V8 blog（实现细节与性能故事）<a href="https://v8.dev/blog" target="_blank" rel="noreferrer">https://v8.dev/blog</a></li><li>Web Browser Engineering（用“能跑的代码”把管线讲清楚）<a href="https://browser.engineering/" target="_blank" rel="noreferrer">https://browser.engineering/</a></li></ul>',63)])])}const p=r(o,[["render",t]]);export{m as __pageData,p as default};
