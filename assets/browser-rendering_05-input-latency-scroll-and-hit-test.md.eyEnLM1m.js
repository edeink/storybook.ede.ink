import{_ as o,C as n,c as s,o as i,j as r,b as d,a2 as p,a as t,w as a,G as c,a3 as u}from"./chunks/framework.C2eRlmqf.js";const x=JSON.parse('{"title":"输入与滚动：事件路由、命中与延迟下限","description":"","frontmatter":{"title":"输入与滚动：事件路由、命中与延迟下限","date":"2026-01-20T00:00:00.000Z","categories":"study","tags":["browser-rendering","chromium","input","latency","scrolling","hit-test","inp"]},"headers":[],"relativePath":"browser-rendering/05-input-latency-scroll-and-hit-test.md","filePath":"browser-rendering/05-input-latency-scroll-and-hit-test.md","lastUpdated":1769026429000}'),m={name:"browser-rendering/05-input-latency-scroll-and-hit-test.md"};function h(_,e,b,f,g,k){const l=n("Mermaid");return i(),s("div",null,[e[1]||(e[1]=r("div",{class:"alert read-stats",role:"note"},[r("span",{class:"read-stats__icon","aria-hidden":"true"},"🔖"),r("span",{class:"read-stats__text"},[t("本文约 "),r("b",null,"784"),t(" 字，阅读预计耗时 "),r("b",null,"2"),t(" 分钟。")])],-1)),e[2]||(e[2]=r("div",{class:"alert ai-disclosure",role:"note"},[r("span",{class:"ai-disclosure__icon","aria-hidden":"true"},"ⓘ"),r("span",{class:"ai-disclosure__text"},"AI 辅助写作声明：本文由博主构思逻辑，AI 辅助润色，双方共同校对。")],-1)),e[3]||(e[3]=r("p",null,"用户感知延迟的本质是：输入发生在 t0，但系统直到 t1 才把“我理解你要干什么”的视觉反馈画出来。渲染链路再复杂，最终都要接受这个 KPI 的拷问。",-1)),e[4]||(e[4]=r("p",null,"这一章从 Chromium 视角把输入链路拆开：事件怎么从系统进入浏览器、怎么路由到目标 frame、怎么命中、滚动为什么尽量走合成线程，以及前端如何把延迟拆成可归因的部分。",-1)),e[5]||(e[5]=r("h2",{id:"_1-输入不是-一个事件-而是一条跨进程管线",tabindex:"-1"},[t("1. 输入不是“一个事件”，而是一条跨进程管线 "),r("a",{class:"header-anchor",href:"#_1-输入不是-一个事件-而是一条跨进程管线","aria-label":'Permalink to "1. 输入不是“一个事件”，而是一条跨进程管线"'},"​")],-1)),e[6]||(e[6]=r("p",null,"粗粒度的链路可以画成这样：",-1)),(i(),d(u,null,{default:a(()=>[c(l,{id:"mermaid-14",class:"mermaid",graph:"flowchart%20LR%0A%20%20OS%5B%22OS%20input%3Cbr%2F%3Etouch%2Fmouse%2Fkeyboard%22%5D%20--%3E%20Browser%5B%22Browser%20process%3Cbr%2F%3Eroute%20%2B%20policy%22%5D%0A%20%20Browser%20--%3E%20Renderer%5B%22Renderer%20process%3Cbr%2F%3Emain%2Fimpl%2Fworker%22%5D%0A%20%20Renderer%20--%3E%20Blink%5B%22Blink%3Cbr%2F%3Edispatch%20%2B%20DOM%20events%22%5D%0A%20%20Blink%20--%3E%20JS%5B%22JS%20handlers%3Cbr%2F%3Eframework%20scheduler%22%5D%0A%20%20JS%20--%3E%20Blink%0A%20%20Blink%20--%3E%20CC%5B%22cc%20draw%22%5D%0A%20%20CC%20--%3E%20Viz%5B%22Viz%20present%22%5D%0A%20%20Viz%20--%3E%20Screen%5B%22screen%22%5D%0A"})]),fallback:a(()=>[...e[0]||(e[0]=[t(" Loading... ",-1)])]),_:1})),e[7]||(e[7]=p('<p>这里有两个容易忽略的事实：</p><ul><li>事件可能跨进程：尤其当目标 frame 在另一个 renderer</li><li>事件可能跨线程：滚动、合成、raster 都可能不在 main thread 上跑</li></ul><h2 id="_2-hit-testing-命中不是免费-它决定了-你点哪儿算哪儿" tabindex="-1">2. Hit testing：命中不是免费，它决定了“你点哪儿算哪儿” <a class="header-anchor" href="#_2-hit-testing-命中不是免费-它决定了-你点哪儿算哪儿" aria-label="Permalink to &quot;2. Hit testing：命中不是免费，它决定了“你点哪儿算哪儿”&quot;">​</a></h2><p>命中（hit test）要回答的问题很朴素：一个坐标点落在谁身上？但在真实网页里它会遇到：</p><ul><li>transform/clip/effect/opacity 叠加</li><li>多层遮挡与 z-order</li><li>iframe 跨进程</li><li>滚动偏移与滚动链</li></ul><p>为了让命中足够快，系统会维护用于命中的数据结构，并在某些阶段更新它们。命中数据更新的时机，决定了交互延迟的下限：如果命中强依赖主线程最新布局，那主线程一忙你就会“点不动”。</p><h2 id="_3-滚动-为什么浏览器宁愿复杂-也要把它从主线程搬走" tabindex="-1">3. 滚动：为什么浏览器宁愿复杂，也要把它从主线程搬走 <a class="header-anchor" href="#_3-滚动-为什么浏览器宁愿复杂-也要把它从主线程搬走" aria-label="Permalink to &quot;3. 滚动：为什么浏览器宁愿复杂，也要把它从主线程搬走&quot;">​</a></h2><p>滚动有两个特性：</p><ul><li>高频：输入设备会持续产生滚动增量</li><li>强反馈：每一帧都需要视觉更新</li></ul><p>因此 Chromium 会尽量让滚动走 compositor thread（impl-thread scrolling）。前端看到的行为差异通常来自：</p><ul><li>能在合成线程处理的滚动：主线程忙也能滚</li><li>必须等主线程的滚动：主线程一忙就卡住（常见原因是滚动链路需要主线程确认、或有阻塞性的事件处理）</li></ul><h2 id="_4-inp-交互延迟-前端口径与底层拆分" tabindex="-1">4. INP/交互延迟：前端口径与底层拆分 <a class="header-anchor" href="#_4-inp-交互延迟-前端口径与底层拆分" aria-label="Permalink to &quot;4. INP/交互延迟：前端口径与底层拆分&quot;">​</a></h2><p>从前端度量看，像 INP（Interaction to Next Paint）这种指标，本质是在衡量：</p><ul><li>事件排队等待（main thread/renderer 忙导致）</li><li>事件处理耗时（JS + DOM 事件分发 + 框架调度）</li><li>结果上屏等待（style/layout/paint + composite + present）</li></ul><p>在排障时建议把它拆成三段：</p><ol><li>输入到 handler 开始：排队/路由开销</li><li>handler 执行：JS/DOM 成本（以及是否触发强制同步）</li><li>handler 结束到 next paint：渲染链路与同步点成本</li></ol><h2 id="_5-前端可操作的几个-延迟杀手" tabindex="-1">5. 前端可操作的几个“延迟杀手” <a class="header-anchor" href="#_5-前端可操作的几个-延迟杀手" aria-label="Permalink to &quot;5. 前端可操作的几个“延迟杀手”&quot;">​</a></h2><ul><li>长任务：把一次交互处理拆成可中断的小块（或搬到 worker），减少 handler 阶段阻塞</li><li>强制同步布局：避免在交互路径上读写交错（尤其是 pointermove/touchmove）</li><li>滚动监听：谨慎对待会阻塞滚动的监听逻辑，尽量让滚动走 compositor</li><li>过度重绘：交互反馈尽量走合成友好路径，否则 next paint 会被 paint/raster 吞掉</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li>Chromium docs（输入/渲染相关入口）<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/" target="_blank" rel="noreferrer">https://chromium.googlesource.com/chromium/src/+/main/docs/</a></li><li>A Pixel（输入到上屏节拍）<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit" target="_blank" rel="noreferrer">https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit</a></li></ul>',20))])}const A=o(m,[["render",h]]);export{x as __pageData,A as default};
